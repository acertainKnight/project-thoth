/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/modals/input-modal.ts
var input_modal_exports = {};
__export(input_modal_exports, {
  InputModal: () => InputModal
});
var import_obsidian, InputModal;
var init_input_modal = __esm({
  "src/modals/input-modal.ts"() {
    import_obsidian = require("obsidian");
    InputModal = class extends import_obsidian.Modal {
      constructor(app, promptText, resolve) {
        super(app);
        this.promptText = promptText;
        this.resolve = resolve;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h3", { text: this.promptText });
        this.inputEl = contentEl.createEl("input", { type: "text" });
        this.inputEl.style.cssText = "width: 100%; padding: 8px; margin: 10px 0; border: 1px solid var(--background-modifier-border); border-radius: 4px;";
        this.inputEl.focus();
        const buttonContainer = contentEl.createEl("div");
        buttonContainer.style.cssText = "display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px;";
        const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
        cancelButton.style.cssText = "padding: 8px 16px; border: 1px solid var(--background-modifier-border); background: var(--background-secondary); border-radius: 4px;";
        cancelButton.onclick = () => {
          this.resolve(null);
          this.close();
        };
        const okButton = buttonContainer.createEl("button", { text: "OK" });
        okButton.style.cssText = "padding: 8px 16px; background: var(--interactive-accent); color: var(--text-on-accent); border: none; border-radius: 4px;";
        okButton.onclick = () => {
          this.resolve(this.inputEl.value.trim() || null);
          this.close();
        };
        this.inputEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            this.resolve(this.inputEl.value.trim() || null);
            this.close();
          } else if (e.key === "Escape") {
            this.resolve(null);
            this.close();
          }
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ThothPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/types/settings.ts
var DEFAULT_SETTINGS = {
  // Connection
  remoteMode: true,
  // Default to remote mode (works on desktop + mobile)
  remoteEndpointUrl: "http://localhost:8000",
  // Thoth API
  lettaEndpointUrl: "http://localhost:8284",
  // Letta API
  // API Keys (empty by default - backend reads from vault/_thoth/settings.json)
  apiKeys: {},
  // Plugin Behavior
  autoStartAgent: false,
  // Don't auto-start by default
  showStatusBar: true,
  showRibbonIcon: true,
  // Chat History
  chatHistoryLimit: 50,
  chatHistory: [],
  // Multi-chat
  enableMultipleChats: true,
  maxChatWindows: 5,
  chatWindowStates: [],
  activeChatSessionId: null,
  lettaAgentId: null,
  // UI Preferences
  theme: "auto",
  compactMode: false,
  showAdvancedSettings: false,
  enableNotifications: true,
  notificationDuration: 5e3
};

// src/modals/multi-chat-modal.ts
var import_obsidian4 = require("obsidian");

// src/components/research-tab.ts
var import_obsidian2 = require("obsidian");
init_input_modal();
var ResearchTabComponent = class {
  constructor(containerEl, plugin) {
    this.questions = [];
    this.selectedQuestion = null;
    this.articles = [];
    this.allArticles = [];
    // Unfiltered copy
    this.currentFilter = "all";
    this.containerEl = containerEl;
    this.plugin = plugin;
  }
  async render() {
    this.containerEl.empty();
    const researchContainer = this.containerEl.createDiv({ cls: "thoth-research-container" });
    const header = researchContainer.createDiv({ cls: "thoth-research-header" });
    header.createEl("h2", { text: "Research Dashboard", cls: "thoth-research-title" });
    const refreshBtn = header.createEl("button", {
      text: "\u21BB Refresh",
      cls: "thoth-refresh-btn"
    });
    refreshBtn.onclick = () => this.refresh();
    await this.loadResearchQuestions();
    this.renderQuestionsSection(researchContainer);
    if (this.selectedQuestion) {
      await this.loadArticles(this.selectedQuestion.id);
      this.renderArticlesSection(researchContainer);
    }
    await this.renderBrowserWorkflowsSection(researchContainer);
    this.renderQuickActionsSection(researchContainer);
  }
  async loadResearchQuestions() {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      console.log("[ResearchTab] Loading research questions from:", `${endpoint}/api/research/questions`);
      const response = await fetch(`${endpoint}/api/research/questions?limit=50&active_only=true`);
      console.log("[ResearchTab] Response status:", response.status);
      if (response.ok) {
        const data = await response.json();
        console.log("[ResearchTab] Received data:", data);
        this.questions = data.questions || [];
        console.log("[ResearchTab] Loaded questions:", this.questions.length);
      } else {
        const errorText = await response.text();
        console.error("[ResearchTab] API error:", response.status, errorText);
        new import_obsidian2.Notice(`Failed to load research questions: ${response.status}`);
      }
    } catch (error) {
      console.error("[ResearchTab] Failed to load research questions:", error);
      new import_obsidian2.Notice("Failed to load research questions");
    }
  }
  renderQuestionsSection(container) {
    const section = container.createDiv({ cls: "thoth-questions-section" });
    const sectionHeader = section.createDiv({ cls: "thoth-section-header" });
    sectionHeader.createEl("h3", { text: "Research Questions" });
    const newQuestionBtn = sectionHeader.createEl("button", {
      text: "+ New Question",
      cls: "thoth-new-question-btn"
    });
    newQuestionBtn.onclick = () => this.createNewQuestion();
    if (this.questions.length === 0) {
      const empty = section.createDiv({ cls: "thoth-empty-state" });
      empty.createEl("div", { text: "\u{1F50D}", cls: "thoth-empty-icon" });
      empty.createEl("h4", { text: "No Research Questions Yet", cls: "thoth-empty-title" });
      empty.createEl("p", {
        text: "Create a research question to start discovering relevant papers automatically.",
        cls: "thoth-empty-description"
      });
    } else {
      const questionsList = section.createDiv({ cls: "thoth-questions-list" });
      this.questions.forEach((question) => {
        var _a;
        const card = questionsList.createDiv({
          cls: `thoth-question-card ${((_a = this.selectedQuestion) == null ? void 0 : _a.id) === question.id ? "active" : ""}`
        });
        card.onclick = () => this.selectQuestion(question);
        const cardHeader = card.createDiv({ cls: "thoth-card-header" });
        cardHeader.createEl("h4", { text: question.name, cls: "thoth-card-title" });
        if (question.new_articles && question.new_articles > 0) {
          const badge = cardHeader.createEl("span", {
            text: `${question.new_articles} new`,
            cls: "thoth-badge-new"
          });
        }
        const meta = card.createDiv({ cls: "thoth-card-meta" });
        const keywordsTags = meta.createDiv({ cls: "thoth-tags" });
        question.keywords.slice(0, 3).forEach((keyword) => {
          keywordsTags.createEl("span", { text: keyword, cls: "thoth-tag" });
        });
        if (question.keywords.length > 3) {
          keywordsTags.createEl("span", {
            text: `+${question.keywords.length - 3}`,
            cls: "thoth-tag thoth-tag-more"
          });
        }
        if (question.total_articles !== void 0) {
          meta.createEl("span", {
            text: `${question.total_articles} articles`,
            cls: "thoth-stat"
          });
        }
        if (question.last_run_at) {
          const timeAgo = this.getTimeAgo(new Date(question.last_run_at));
          meta.createEl("span", {
            text: `Updated ${timeAgo}`,
            cls: "thoth-time-ago"
          });
        }
      });
    }
  }
  async renderArticlesSection(container) {
    if (!this.selectedQuestion)
      return;
    const section = container.createDiv({ cls: "thoth-articles-section" });
    const sectionHeader = section.createDiv({ cls: "thoth-section-header" });
    sectionHeader.createEl("h3", {
      text: `Discovered Papers: ${this.selectedQuestion.name}`
    });
    const runDiscoveryBtn = sectionHeader.createEl("button", {
      text: "\u25B6 Run Discovery",
      cls: "thoth-run-discovery-btn"
    });
    runDiscoveryBtn.onclick = () => this.runDiscovery(this.selectedQuestion.id);
    const filters = section.createDiv({ cls: "thoth-filters" });
    const filterButtons = [
      { label: "All", filter: "all" },
      { label: "New", filter: "new" },
      { label: "Liked", filter: "liked" }
    ];
    filterButtons.forEach(({ label, filter }) => {
      const btn = filters.createEl("button", {
        text: label,
        cls: filter === this.currentFilter ? "thoth-filter-btn active" : "thoth-filter-btn"
      });
      btn.onclick = () => this.filterArticles(filter);
    });
    const articlesList = section.createDiv({ cls: "thoth-articles-list" });
    if (this.articles.length === 0) {
      const empty = articlesList.createDiv({ cls: "thoth-empty-state" });
      empty.createEl("div", { text: "\u{1F4C4}", cls: "thoth-empty-icon" });
      empty.createEl("p", { text: "No articles found yet. Run discovery to find papers." });
    } else {
      this.articles.forEach((article) => {
        this.renderArticleCard(articlesList, article);
      });
    }
  }
  renderArticleCard(container, article) {
    const card = container.createDiv({ cls: "thoth-article-card" });
    const header = card.createDiv({ cls: "thoth-article-header" });
    const title = header.createEl("h4", { text: article.title, cls: "thoth-article-title" });
    title.onclick = () => this.viewArticle(article);
    const relevancePct = Math.round(article.relevance_score * 100);
    const badge = header.createEl("span", {
      text: `${relevancePct}%`,
      cls: `thoth-relevance-badge ${relevancePct >= 80 ? "high" : relevancePct >= 60 ? "medium" : "low"}`
    });
    const meta = card.createDiv({ cls: "thoth-article-meta" });
    if (article.authors && article.authors.length > 0) {
      meta.createEl("span", {
        text: article.authors.slice(0, 2).join(", ") + (article.authors.length > 2 ? " et al." : ""),
        cls: "thoth-authors"
      });
    }
    if (article.publication_date) {
      const year = new Date(article.publication_date).getFullYear();
      meta.createEl("span", { text: `${year}`, cls: "thoth-year" });
    }
    if (article.discovered_via_source) {
      meta.createEl("span", {
        text: article.discovered_via_source,
        cls: "thoth-source"
      });
    }
    if (article.abstract) {
      const abstractText = article.abstract;
      const abstractContainer = card.createDiv({ cls: "thoth-abstract-container" });
      const needsTruncation = abstractText.length > 200;
      const abstract = abstractContainer.createEl("p", {
        text: needsTruncation ? abstractText.slice(0, 200) + "..." : abstractText,
        cls: "thoth-article-abstract"
      });
      if (needsTruncation) {
        const toggleBtn = abstractContainer.createEl("button", {
          text: "Show more",
          cls: "thoth-abstract-toggle"
        });
        let isExpanded = false;
        toggleBtn.onclick = (e) => {
          e.stopPropagation();
          isExpanded = !isExpanded;
          abstract.setText(isExpanded ? abstractText : abstractText.slice(0, 200) + "...");
          toggleBtn.setText(isExpanded ? "Show less" : "Show more");
        };
      }
    }
    if (article.matched_keywords && article.matched_keywords.length > 0) {
      const tags = card.createDiv({ cls: "thoth-matched-tags" });
      article.matched_keywords.forEach((keyword) => {
        tags.createEl("span", { text: keyword, cls: "thoth-tag thoth-tag-matched" });
      });
    }
    const actions = card.createDiv({ cls: "thoth-article-actions" });
    if (article.pdf_url) {
      const downloadBtn = actions.createEl("button", {
        text: "\u2B07 PDF",
        cls: "thoth-action-btn"
      });
      downloadBtn.onclick = () => this.downloadArticle(article);
    }
    const viewBtn = actions.createEl("button", {
      text: "\u{1F441} View",
      cls: `thoth-action-btn ${article.is_viewed ? "active" : ""}`
    });
    viewBtn.onclick = () => this.viewArticle(article);
    const ratingGroup = actions.createDiv({ cls: "thoth-rating-group" });
    const likeBtn = ratingGroup.createEl("button", {
      text: "\u{1F44D}",
      cls: `thoth-rating-btn ${article.user_sentiment === "like" ? "active" : ""}`
    });
    likeBtn.onclick = () => this.rateArticle(article, "like");
    const dislikeBtn = ratingGroup.createEl("button", {
      text: "\u{1F44E}",
      cls: `thoth-rating-btn ${article.user_sentiment === "dislike" ? "active" : ""}`
    });
    dislikeBtn.onclick = () => this.rateArticle(article, "dislike");
  }
  async loadArticles(questionId) {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      console.log("[ResearchTab] Loading articles for question:", questionId);
      const response = await fetch(
        `${endpoint}/api/research/questions/${questionId}/articles?limit=50`
      );
      console.log("[ResearchTab] Articles response status:", response.status);
      if (response.ok) {
        const data = await response.json();
        console.log("[ResearchTab] Received articles data:", data);
        this.allArticles = data.matches || [];
        this.articles = [...this.allArticles];
        this.currentFilter = "all";
        console.log("[ResearchTab] Loaded articles:", this.articles.length);
      } else {
        const errorText = await response.text();
        console.error("[ResearchTab] Articles API error:", response.status, errorText);
      }
    } catch (error) {
      console.error("[ResearchTab] Failed to load articles:", error);
      new import_obsidian2.Notice("Failed to load articles");
    }
  }
  async selectQuestion(question) {
    this.selectedQuestion = question;
    await this.render();
  }
  async rateArticle(article, sentiment) {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(
        `${endpoint}/api/research/questions/${this.selectedQuestion.id}/articles/${article.match_id}/sentiment`,
        {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sentiment })
        }
      );
      if (response.ok) {
        article.user_sentiment = sentiment;
        await this.render();
        new import_obsidian2.Notice(`Marked as ${sentiment}`);
      } else {
        throw new Error("Failed to rate article");
      }
    } catch (error) {
      console.error("Error rating article:", error);
      new import_obsidian2.Notice("Failed to rate article");
    }
  }
  async toggleViewed(article) {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const newValue = !article.is_viewed;
      const response = await fetch(
        `${endpoint}/api/research/questions/${this.selectedQuestion.id}/articles/${article.match_id}/status`,
        {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ is_viewed: newValue })
        }
      );
      if (response.ok) {
        article.is_viewed = newValue;
        await this.render();
      } else {
        throw new Error("Failed to update status");
      }
    } catch (error) {
      console.error("Error updating viewed status:", error);
      new import_obsidian2.Notice("Failed to update status");
    }
  }
  async toggleBookmark(article) {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const newValue = !article.is_bookmarked;
      const response = await fetch(
        `${endpoint}/api/research/questions/${this.selectedQuestion.id}/articles/${article.match_id}/status`,
        {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ is_bookmarked: newValue })
        }
      );
      if (response.ok) {
        article.is_bookmarked = newValue;
        await this.render();
        new import_obsidian2.Notice(newValue ? "Bookmarked" : "Removed bookmark");
      } else {
        throw new Error("Failed to update bookmark");
      }
    } catch (error) {
      console.error("Error updating bookmark:", error);
      new import_obsidian2.Notice("Failed to update bookmark");
    }
  }
  async saveArticle(article) {
    try {
      if (!article.pdf_url) {
        new import_obsidian2.Notice("No PDF URL available for this article");
        return;
      }
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(
        `${endpoint}/api/research/questions/${this.selectedQuestion.id}/articles/${article.match_id}/download`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" }
        }
      );
      if (response.ok) {
        const result = await response.json();
        new import_obsidian2.Notice(`PDF downloaded! File monitor will process automatically.`);
        article.is_bookmarked = true;
        article.is_viewed = true;
        await this.render();
        console.log("Download result:", result);
      } else {
        const error = await response.json();
        throw new Error(error.detail || "Failed to download");
      }
    } catch (error) {
      console.error("Error saving article:", error);
      new import_obsidian2.Notice(`Failed to save article: ${error.message}`);
    }
  }
  async downloadArticle(article) {
    await this.saveArticle(article);
  }
  async viewArticle(article) {
    if (!article.is_viewed) {
      await this.toggleViewed(article);
    }
    const url = article.doi ? `https://doi.org/${article.doi}` : article.pdf_url;
    if (url) {
      try {
        require("electron").shell.openExternal(url);
      } catch (error) {
        console.warn("electron.shell not available, using window.open");
        window.open(url, "_blank");
      }
    } else {
      new import_obsidian2.Notice("No URL available for this article");
    }
  }
  async runDiscovery(questionId) {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(
        `${endpoint}/api/research/questions/${questionId}/run`,
        { method: "POST" }
      );
      if (response.ok) {
        new import_obsidian2.Notice("Discovery started - check back in a few minutes");
        setTimeout(() => this.refresh(), 3e3);
      } else {
        throw new Error("Failed to run discovery");
      }
    } catch (error) {
      console.error("Error running discovery:", error);
      new import_obsidian2.Notice("Failed to run discovery");
    }
  }
  async createNewQuestion() {
    const name = await new Promise((resolve) => {
      new InputModal(this.plugin.app, "Enter research question name:", resolve).open();
    });
    if (!name)
      return;
    const keywords = await new Promise((resolve) => {
      new InputModal(this.plugin.app, "Enter keywords (comma-separated):", resolve).open();
    });
    if (!keywords)
      return;
    const keywordsList = keywords.split(",").map((k) => k.trim()).filter((k) => k);
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(`${endpoint}/api/research/questions`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name,
          keywords: keywordsList,
          topics: [],
          authors: [],
          selected_sources: ["*"],
          // All sources
          schedule_frequency: "on-demand",
          min_relevance_score: 0.5,
          auto_download_pdfs: false,
          auto_process_pdfs: false,
          max_articles_per_run: 50
        })
      });
      if (response.ok) {
        new import_obsidian2.Notice("Research question created!");
        await this.refresh();
      } else {
        const error = await response.json();
        throw new Error(error.detail || "Failed to create question");
      }
    } catch (error) {
      console.error("Error creating research question:", error);
      new import_obsidian2.Notice(`Failed to create research question: ${error.message}`);
    }
  }
  async filterArticles(filter) {
    this.currentFilter = filter;
    let filtered = [...this.allArticles];
    switch (filter) {
      case "new":
        filtered = filtered.filter((a) => !a.is_viewed);
        break;
      case "liked":
        filtered = filtered.filter((a) => a.user_sentiment === "like");
        break;
      case "all":
      default:
        break;
    }
    this.articles = filtered;
    await this.render();
  }
  async refresh() {
    await this.render();
    new import_obsidian2.Notice("Refreshed");
  }
  getTimeAgo(date) {
    const seconds = Math.floor((new Date().getTime() - date.getTime()) / 1e3);
    if (seconds < 60)
      return "just now";
    if (seconds < 3600)
      return `${Math.floor(seconds / 60)}m ago`;
    if (seconds < 86400)
      return `${Math.floor(seconds / 3600)}h ago`;
    if (seconds < 604800)
      return `${Math.floor(seconds / 86400)}d ago`;
    return date.toLocaleDateString();
  }
  // Browser Workflows Section
  async renderBrowserWorkflowsSection(container) {
    const section = container.createDiv({ cls: "thoth-workflows-section" });
    const sectionHeader = section.createDiv({ cls: "thoth-section-header" });
    sectionHeader.createEl("h3", { text: "\u{1F310} Browser Workflows" });
    const createBtn = sectionHeader.createEl("button", {
      text: "+ Create Workflow",
      cls: "thoth-create-btn"
    });
    createBtn.onclick = () => {
      new import_obsidian2.Notice("Browser workflow creation coming soon! Use backend API for now.");
    };
    const workflowsList = section.createDiv({ cls: "thoth-workflows-list" });
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(`${endpoint}/api/workflows`);
      if (response.ok) {
        const workflows = await response.json();
        if (workflows.length === 0) {
          const empty = workflowsList.createDiv({ cls: "thoth-empty-state-small" });
          empty.createEl("p", {
            text: "No browser workflows yet. Create one to automate paper discovery from custom sources.",
            cls: "thoth-empty-text"
          });
        } else {
          workflows.forEach((workflow) => {
            this.renderWorkflowCard(workflowsList, workflow);
          });
        }
      }
    } catch (error) {
      workflowsList.createEl("p", {
        text: "Unable to load workflows",
        cls: "thoth-error-text"
      });
    }
  }
  renderWorkflowCard(container, workflow) {
    const card = container.createDiv({ cls: "thoth-workflow-card" });
    const header = card.createDiv({ cls: "thoth-workflow-header" });
    header.createEl("span", {
      text: workflow.name || "Unnamed Workflow",
      cls: "thoth-workflow-name"
    });
    const status = header.createEl("span", {
      cls: `thoth-workflow-status ${workflow.is_active ? "active" : "inactive"}`
    });
    status.setText(workflow.is_active ? "\u25CF Active" : "\u25CB Inactive");
    if (workflow.schedule) {
      card.createEl("p", {
        text: `Schedule: ${workflow.schedule}`,
        cls: "thoth-workflow-schedule"
      });
    }
    const actions = card.createDiv({ cls: "thoth-workflow-actions" });
    const runBtn = actions.createEl("button", {
      text: "\u25B6 Run",
      cls: "thoth-workflow-run-btn"
    });
    runBtn.onclick = async () => {
      try {
        const endpoint = this.plugin.getEndpointUrl();
        await fetch(`${endpoint}/api/workflows/${workflow.id}/execute`, {
          method: "POST"
        });
        new import_obsidian2.Notice(`Executing workflow: ${workflow.name}`);
      } catch (error) {
        new import_obsidian2.Notice("Failed to execute workflow");
      }
    };
  }
  // Quick Actions Section
  renderQuickActionsSection(container) {
    const section = container.createDiv({ cls: "thoth-quick-actions-section" });
    const sectionHeader = section.createDiv({ cls: "thoth-section-header" });
    sectionHeader.createEl("h3", { text: "\u26A1 Quick Actions" });
    const actionsGrid = section.createDiv({ cls: "thoth-quick-actions-grid" });
    this.createQuickAction(
      actionsGrid,
      "\u{1F50D}",
      "Search Knowledge Base",
      "Search your processed articles and notes",
      () => {
        new import_obsidian2.Notice("Opening knowledge base search...");
      }
    );
    this.createQuickAction(
      actionsGrid,
      "\u{1F4C4}",
      "Process PDF",
      "Upload and process a new research paper",
      () => {
        new import_obsidian2.Notice("PDF processing UI coming soon! Drop PDFs in your vault/_thoth/data/pdfs folder.");
      }
    );
    this.createQuickAction(
      actionsGrid,
      "\u{1F4CA}",
      "View Statistics",
      "See your research collection stats",
      async () => {
        try {
          const endpoint = this.plugin.getEndpointUrl();
          const response = await fetch(`${endpoint}/health`);
          if (response.ok || response.status === 503) {
            const data = await response.json();
            const status = data.healthy ? "\u2713 Healthy" : "\u26A0 Partially Degraded";
            new import_obsidian2.Notice(`System: ${status}. Services: ${Object.keys(data.services || {}).length}`);
          } else {
            new import_obsidian2.Notice(`Unable to fetch health status (${response.status})`);
          }
        } catch (error) {
          new import_obsidian2.Notice("Unable to connect to backend");
        }
      }
    );
  }
  createQuickAction(container, icon, title, description, onClick) {
    const action = container.createDiv({ cls: "thoth-quick-action" });
    action.createEl("div", {
      text: icon,
      cls: "thoth-action-icon"
    });
    action.createEl("div", {
      text: title,
      cls: "thoth-action-title"
    });
    action.createEl("div", {
      text: description,
      cls: "thoth-action-description"
    });
    action.onclick = onClick;
  }
  async createNoteFromArticle(article) {
    var _a, _b, _c, _d;
    try {
      const vault = this.plugin.app.vault;
      const folderPath = "Research/Papers";
      const folder = vault.getAbstractFileByPath(folderPath);
      if (!folder) {
        await vault.createFolder(folderPath);
      }
      const filename = this.sanitizeFilename(article.title);
      const notePath = `${folderPath}/${filename}.md`;
      const existingFile = vault.getAbstractFileByPath(notePath);
      if (existingFile) {
        new import_obsidian2.Notice("Note already exists! Opening it...");
        const leaf = this.plugin.app.workspace.getLeaf(false);
        await leaf.openFile(existingFile);
        return;
      }
      const authors = ((_a = article.authors) == null ? void 0 : _a.join(", ")) || "Unknown";
      const year = article.publication_date ? new Date(article.publication_date).getFullYear() : "n.d.";
      const url = article.doi ? `https://doi.org/${article.doi}` : article.pdf_url || "No URL";
      const content = `---
title: "${article.title}"
authors: ${authors}
year: ${year}
relevance: ${Math.round(article.relevance_score * 100)}%
source: ${article.discovered_via_source || "unknown"}
doi: ${article.doi || ""}
url: ${url}
question: ${((_b = this.selectedQuestion) == null ? void 0 : _b.name) || ""}
tags:
  - research/paper
  - from-thoth
---

# ${article.title}

## Metadata
- **Authors:** ${authors}
- **Year:** ${year}
- **Relevance:** ${Math.round(article.relevance_score * 100)}%
- **Source:** ${article.discovered_via_source || "unknown"}
${article.doi ? `- **DOI:** [${article.doi}](https://doi.org/${article.doi})` : ""}
${article.pdf_url ? `- **PDF:** [Download](${article.pdf_url})` : ""}

## Abstract

${article.abstract || "No abstract available."}

## Matched Keywords

${((_c = article.matched_keywords) == null ? void 0 : _c.map((k) => `- ${k}`).join("\n")) || "None"}

## Notes

<!-- Add your reading notes here -->

---

*Generated from Thoth research question: "${(_d = this.selectedQuestion) == null ? void 0 : _d.name}"*
`;
      await vault.create(notePath, content);
      if (!article.is_viewed) {
        await this.toggleViewed(article);
      }
      if (!article.is_bookmarked) {
        await this.toggleBookmark(article);
      }
      new import_obsidian2.Notice(`Note created: ${filename}`);
      const file = vault.getAbstractFileByPath(notePath);
      if (file) {
        const leaf = this.plugin.app.workspace.getLeaf(false);
        await leaf.openFile(file);
      }
    } catch (error) {
      console.error("Error creating note from article:", error);
      new import_obsidian2.Notice("Failed to create note");
    }
  }
  sanitizeFilename(title) {
    let filename = title.replace(/[<>:"/\\|?*]/g, "");
    filename = filename.replace(/\s+/g, " ");
    filename = filename.trim().substring(0, 100);
    return filename;
  }
};

// src/components/settings-tab.ts
var import_obsidian3 = require("obsidian");
var SettingsTabComponent = class {
  constructor(containerEl, plugin) {
    this.containerEl = containerEl;
    this.plugin = plugin;
    this.settings = plugin.settings;
  }
  render() {
    this.containerEl.empty();
    const settingsContainer = this.containerEl.createDiv({ cls: "thoth-settings-container" });
    const header = settingsContainer.createDiv({ cls: "thoth-settings-header" });
    header.createEl("h2", { text: "Thoth Plugin Settings", cls: "thoth-settings-title" });
    header.createEl("p", {
      text: "Plugin configuration only. Backend settings (API keys, LLM models, paths, etc.) are in vault/_thoth/settings.json",
      cls: "thoth-settings-description"
    });
    this.renderConnectionSection(settingsContainer);
    if (!import_obsidian3.Platform.isMobile) {
      this.renderPluginBehaviorSection(settingsContainer);
    }
    this.renderUIPreferencesSection(settingsContainer);
    this.renderBackendSettingsInfo(settingsContainer);
    const saveButton = settingsContainer.createEl("button", {
      text: "Save Settings",
      cls: "thoth-save-settings-btn"
    });
    saveButton.onclick = () => this.saveSettings();
  }
  renderConnectionSection(container) {
    const section = container.createDiv({ cls: "thoth-settings-section" });
    section.createEl("h3", { text: "\u{1F517} Connection" });
    const remoteModeRow = section.createDiv({ cls: "thoth-setting-row" });
    remoteModeRow.createEl("label", { text: "Remote Mode" });
    const remoteModeToggle = remoteModeRow.createEl("input", { type: "checkbox" });
    remoteModeToggle.checked = this.settings.remoteMode;
    remoteModeToggle.onchange = () => {
      this.settings.remoteMode = remoteModeToggle.checked;
      this.render();
    };
    remoteModeRow.createEl("span", {
      text: "Connect to remote server (unchecked = manage local agent on desktop)",
      cls: "thoth-setting-description"
    });
    if (this.settings.remoteMode) {
      const thothEndpointRow = section.createDiv({ cls: "thoth-setting-row" });
      thothEndpointRow.createEl("label", { text: "Thoth API URL" });
      const thothEndpointInput = thothEndpointRow.createEl("input", { type: "text" });
      thothEndpointInput.value = this.settings.remoteEndpointUrl || "http://localhost:8000";
      thothEndpointInput.placeholder = "http://localhost:8000";
      thothEndpointInput.oninput = () => {
        this.settings.remoteEndpointUrl = thothEndpointInput.value;
      };
      thothEndpointRow.createEl("span", {
        text: "Thoth backend server for research/discovery (e.g., http://localhost:8000)",
        cls: "thoth-setting-description"
      });
      const lettaEndpointRow = section.createDiv({ cls: "thoth-setting-row" });
      lettaEndpointRow.createEl("label", { text: "Letta API URL" });
      const lettaEndpointInput = lettaEndpointRow.createEl("input", { type: "text" });
      lettaEndpointInput.value = this.settings.lettaEndpointUrl || "http://localhost:8284";
      lettaEndpointInput.placeholder = "http://localhost:8284";
      lettaEndpointInput.oninput = () => {
        this.settings.lettaEndpointUrl = lettaEndpointInput.value;
      };
      lettaEndpointRow.createEl("span", {
        text: "Letta backend server for AI agent chats (e.g., http://localhost:8284)",
        cls: "thoth-setting-description"
      });
    }
  }
  renderBackendSettingsInfo(container) {
    const section = container.createDiv({ cls: "thoth-settings-section" });
    section.createEl("h3", { text: "\u2699\uFE0F Backend Configuration" });
    const info = section.createDiv({ cls: "thoth-setting-info" });
    info.createEl("p", {
      text: "Backend settings (API keys, LLM models, paths, discovery config, etc.) are stored separately in:"
    });
    const pathCode = info.createEl("code", {
      text: "vault/_thoth/settings.json",
      cls: "thoth-settings-path"
    });
    info.createEl("p", {
      text: "Edit that file directly or use the setup wizard to configure backend settings."
    });
    if (!import_obsidian3.Platform.isMobile) {
      const openBtn = section.createEl("button", {
        text: "\u{1F4DD} Open Backend Settings File",
        cls: "thoth-open-backend-settings-btn"
      });
      openBtn.onclick = () => {
        const vaultPath = this.plugin.app.vault.adapter.basePath;
        const settingsPath = `${vaultPath}/_thoth/settings.json`;
        const { exec: exec2 } = require("child_process");
        exec2(`xdg-open "${settingsPath}" || open "${settingsPath}" || start "" "${settingsPath}"`, (error) => {
          if (error) {
            new import_obsidian3.Notice("Could not open settings file. Open manually at: _thoth/settings.json");
          } else {
            new import_obsidian3.Notice("Opening backend settings file...");
          }
        });
      };
    }
  }
  renderPluginBehaviorSection(container) {
    const section = container.createDiv({ cls: "thoth-settings-section" });
    section.createEl("h3", { text: "\u2699\uFE0F Plugin Behavior" });
    const autoStartRow = section.createDiv({ cls: "thoth-setting-row" });
    autoStartRow.createEl("label", { text: "Auto-start Agent" });
    const autoStartToggle = autoStartRow.createEl("input", { type: "checkbox" });
    autoStartToggle.checked = this.settings.autoStartAgent;
    autoStartToggle.onchange = () => {
      this.settings.autoStartAgent = autoStartToggle.checked;
    };
    autoStartRow.createEl("span", {
      text: "Automatically start Thoth agent when Obsidian starts (desktop only)",
      cls: "thoth-setting-description"
    });
    const statusBarRow = section.createDiv({ cls: "thoth-setting-row" });
    statusBarRow.createEl("label", { text: "Show Status Bar" });
    const statusBarToggle = statusBarRow.createEl("input", { type: "checkbox" });
    statusBarToggle.checked = this.settings.showStatusBar;
    statusBarToggle.onchange = () => {
      this.settings.showStatusBar = statusBarToggle.checked;
    };
    const ribbonRow = section.createDiv({ cls: "thoth-setting-row" });
    ribbonRow.createEl("label", { text: "Show Ribbon Icon" });
    const ribbonToggle = ribbonRow.createEl("input", { type: "checkbox" });
    ribbonToggle.checked = this.settings.showRibbonIcon;
    ribbonToggle.onchange = () => {
      this.settings.showRibbonIcon = ribbonToggle.checked;
    };
  }
  renderUIPreferencesSection(container) {
    const section = container.createDiv({ cls: "thoth-settings-section" });
    section.createEl("h3", { text: "\u{1F3A8} UI Preferences" });
    const themeRow = section.createDiv({ cls: "thoth-setting-row" });
    themeRow.createEl("label", { text: "Theme" });
    const themeSelect = themeRow.createEl("select");
    ["auto", "light", "dark"].forEach((theme) => {
      const option = themeSelect.createEl("option", { value: theme, text: theme });
      if (theme === this.settings.theme) {
        option.selected = true;
      }
    });
    themeSelect.onchange = () => {
      this.settings.theme = themeSelect.value;
    };
    const compactRow = section.createDiv({ cls: "thoth-setting-row" });
    compactRow.createEl("label", { text: "Compact Mode" });
    const compactToggle = compactRow.createEl("input", { type: "checkbox" });
    compactToggle.checked = this.settings.compactMode;
    compactToggle.onchange = () => {
      this.settings.compactMode = compactToggle.checked;
    };
    const notificationsRow = section.createDiv({ cls: "thoth-setting-row" });
    notificationsRow.createEl("label", { text: "Enable Notifications" });
    const notificationsToggle = notificationsRow.createEl("input", { type: "checkbox" });
    notificationsToggle.checked = this.settings.enableNotifications;
    notificationsToggle.onchange = () => {
      this.settings.enableNotifications = notificationsToggle.checked;
    };
  }
  async saveSettings() {
    try {
      await this.plugin.saveSettings();
      new import_obsidian3.Notice("Settings saved successfully!");
    } catch (error) {
      console.error("Failed to save settings:", error);
      new import_obsidian3.Notice("Failed to save settings");
    }
  }
};

// src/modals/multi-chat-modal.ts
var MultiChatModal = class extends import_obsidian4.Modal {
  constructor(app, plugin) {
    super(app);
    this.chatSessions = [];
    this.activeSessionId = null;
    this.chatWindows = /* @__PURE__ */ new Map();
    // Tab system
    this.currentTab = "chat";
    this.plugin = plugin;
  }
  /**
   * Fetch with timeout to prevent UI from hanging
   */
  async fetchWithTimeout(url, options = {}, timeoutMs = 3e4) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    try {
      console.log(`[MultiChatModal] Fetching: ${url}`);
      const startTime = Date.now();
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      });
      const duration = Date.now() - startTime;
      console.log(`[MultiChatModal] Response ${response.status} in ${duration}ms`);
      clearTimeout(timeoutId);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      if (error.name === "AbortError") {
        console.error(`[MultiChatModal] Request timed out after ${timeoutMs}ms:`, url);
        throw new Error(`Request timed out after ${timeoutMs / 1e3}s - check network connection`);
      }
      console.error(`[MultiChatModal] Fetch error:`, error);
      throw error;
    }
  }
  async onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    this.setupModalPosition();
    this.titleEl.setText("\u{1F9E0} Thoth Chat");
    await this.loadChatSessions();
    this.createLayout();
    this.renderSessionList();
    if (this.plugin.settings.activeChatSessionId) {
      const sessionExists = this.chatSessions.find((s) => s.id === this.plugin.settings.activeChatSessionId);
      if (sessionExists) {
        await this.switchToSession(this.plugin.settings.activeChatSessionId);
      } else if (this.chatSessions.length > 0) {
        await this.switchToSession(this.chatSessions[0].id);
      } else {
        await this.createNewSession("Default Chat");
      }
    } else if (this.chatSessions.length > 0) {
      await this.switchToSession(this.chatSessions[0].id);
    } else {
      await this.createNewSession("Default Chat");
    }
    this.makeDraggable();
    this.setupKeyboardShortcuts();
  }
  setupModalPosition() {
    const modalEl = this.modalEl;
    modalEl.addClass("thoth-chat-popup");
    if (this.app.isMobile) {
      modalEl.addClass("thoth-mobile-modal");
      modalEl.style.position = "fixed";
      modalEl.style.top = "0";
      modalEl.style.left = "0";
      modalEl.style.right = "0";
      modalEl.style.bottom = "0";
      modalEl.style.width = "100vw";
      modalEl.style.height = "100vh";
      modalEl.style.maxWidth = "100vw";
      modalEl.style.maxHeight = "100vh";
      modalEl.style.borderRadius = "0";
      modalEl.style.resize = "none";
      modalEl.style.transform = "none";
      modalEl.style.zIndex = "1000";
      modalEl.style.overflow = "hidden";
    } else {
      const backdrop = modalEl.parentElement;
      if (backdrop && backdrop.classList.contains("modal-container")) {
        backdrop.style.backgroundColor = "transparent";
        backdrop.style.pointerEvents = "none";
        backdrop.addClass("thoth-transparent-backdrop");
        modalEl.style.pointerEvents = "auto";
      }
      setTimeout(() => {
        var _a;
        const modalBackdrop = (_a = document.querySelector(".modal-container:has(.thoth-chat-popup), .modal-container .thoth-chat-popup")) == null ? void 0 : _a.parentElement;
        if (modalBackdrop) {
          modalBackdrop.style.backgroundColor = "transparent";
          modalBackdrop.style.pointerEvents = "none";
          modalEl.style.pointerEvents = "auto";
        }
      }, 100);
      modalEl.style.position = "fixed";
      modalEl.style.bottom = "20px";
      modalEl.style.right = "20px";
      modalEl.style.top = "unset";
      modalEl.style.left = "unset";
      modalEl.style.transform = "none";
      modalEl.style.width = "450px";
      modalEl.style.height = "600px";
      modalEl.style.maxWidth = "90vw";
      modalEl.style.maxHeight = "80vh";
      modalEl.style.zIndex = "1000";
      modalEl.style.borderRadius = "12px";
      modalEl.style.boxShadow = "0 8px 32px rgba(0, 0, 0, 0.3)";
      modalEl.style.resize = "both";
      modalEl.style.overflow = "hidden";
    }
  }
  makeDraggable() {
    const modalEl = this.modalEl;
    const titleEl = this.titleEl;
    if (this.app.isMobile) {
      titleEl.style.cursor = "default";
      titleEl.style.userSelect = "none";
      titleEl.style.padding = "15px 20px";
      titleEl.style.background = "var(--background-secondary)";
      titleEl.style.borderBottom = "1px solid var(--background-modifier-border)";
      titleEl.style.borderRadius = "0";
      titleEl.style.fontSize = "16px";
      return;
    }
    let isDragging = false;
    let currentX = 0;
    let currentY = 0;
    let initialX = 0;
    let initialY = 0;
    let xOffset = 0;
    let yOffset = 0;
    titleEl.style.cursor = "move";
    titleEl.style.userSelect = "none";
    titleEl.style.padding = "10px 15px";
    titleEl.style.background = "var(--background-secondary)";
    titleEl.style.borderBottom = "1px solid var(--background-modifier-border)";
    titleEl.style.borderRadius = "12px 12px 0 0";
    titleEl.addEventListener("mousedown", dragStart);
    document.addEventListener("mousemove", drag);
    document.addEventListener("mouseup", dragEnd);
    function dragStart(e) {
      if (e.target !== titleEl)
        return;
      initialX = e.clientX - xOffset;
      initialY = e.clientY - yOffset;
      if (e.target === titleEl) {
        isDragging = true;
        modalEl.style.cursor = "grabbing";
      }
    }
    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
        xOffset = currentX;
        yOffset = currentY;
        const rect = modalEl.getBoundingClientRect();
        const maxX = window.innerWidth - rect.width;
        const maxY = window.innerHeight - rect.height;
        currentX = Math.max(0, Math.min(currentX, maxX));
        currentY = Math.max(0, Math.min(currentY, maxY));
        modalEl.style.right = "unset";
        modalEl.style.bottom = "unset";
        modalEl.style.left = currentX + "px";
        modalEl.style.top = currentY + "px";
      }
    }
    function dragEnd() {
      initialX = currentX;
      initialY = currentY;
      isDragging = false;
      modalEl.style.cursor = "auto";
    }
  }
  setupKeyboardShortcuts() {
    const handleKeydown = (e) => {
      const activeElement = document.activeElement;
      const isInputFocused = (activeElement == null ? void 0 : activeElement.tagName) === "TEXTAREA" || (activeElement == null ? void 0 : activeElement.tagName) === "INPUT";
      if (!isInputFocused) {
        if (e.ctrlKey || e.metaKey) {
          switch (e.key) {
            case "n":
              e.preventDefault();
              this.createNewSession();
              break;
            case "t":
              e.preventDefault();
              this.toggleSidebar();
              break;
          }
        }
      }
    };
    document.addEventListener("keydown", handleKeydown);
    this.modalEl.addEventListener("remove", () => {
      document.removeEventListener("keydown", handleKeydown);
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  createLayout() {
    const { contentEl } = this;
    this.addStyles();
    const mainContainer = contentEl.createEl("div", { cls: "multi-chat-container compact" });
    this.createTabNavigation(mainContainer);
    const sidebar = mainContainer.createEl("div", { cls: "chat-sidebar collapsed" });
    this.sidebar = sidebar;
    this.sessionListContainer = sidebar.createEl("div", { cls: "session-list compact" });
    this.setupSidebarClickOutside(mainContainer);
    this.contentContainer = mainContainer.createEl("div", { cls: "tab-content-container" });
    this.renderTabContent();
  }
  toggleSidebar() {
    if (!this.sidebar)
      return;
    const isCollapsed = this.sidebar.hasClass("collapsed");
    if (isCollapsed) {
      this.sidebar.removeClass("collapsed");
      this.renderSessionList();
    } else {
      this.sidebar.addClass("collapsed");
    }
  }
  closeSidebar() {
    if (!this.sidebar)
      return;
    this.sidebar.addClass("collapsed");
  }
  openSidebar() {
    if (!this.sidebar)
      return;
    this.sidebar.removeClass("collapsed");
    this.renderSessionList();
  }
  setupSidebarClickOutside(mainContainer) {
    mainContainer.addEventListener("click", (e) => {
      var _a;
      if (!((_a = this.sidebar) == null ? void 0 : _a.hasClass("collapsed"))) {
        const target = e.target;
        if (!this.sidebar.contains(target) && !target.hasClass("toggle-sidebar-btn") && !target.closest(".toggle-sidebar-btn")) {
          this.closeSidebar();
        }
      }
    });
  }
  createTabNavigation(container) {
    this.tabContainer = container.createEl("div", { cls: "thoth-tab-navigation" });
    const tabs = [
      { id: "chat", label: "\u{1F4AC} Chat", icon: "message-circle" },
      { id: "conversations", label: "\u{1F4DD} Conversations", icon: "message-square" },
      { id: "research", label: "\u{1F52C} Research", icon: "beaker" },
      { id: "settings", label: "\u2699\uFE0F Settings", icon: "settings" }
    ];
    tabs.forEach((tab) => {
      const button = this.tabContainer.createEl("button", {
        text: tab.label,
        cls: "thoth-tab-button"
      });
      if (tab.id === this.currentTab) {
        button.addClass("active");
      }
      button.onclick = () => this.switchTab(tab.id);
    });
  }
  async switchTab(tabId) {
    this.tabContainer.querySelectorAll(".thoth-tab-button").forEach((btn, index) => {
      if (index === ["chat", "conversations", "research", "settings"].indexOf(tabId)) {
        btn.addClass("active");
      } else {
        btn.removeClass("active");
      }
    });
    this.currentTab = tabId;
    await this.renderTabContent();
  }
  async renderTabContent() {
    if (!this.contentContainer)
      return;
    this.contentContainer.empty();
    switch (this.currentTab) {
      case "chat":
        this.renderChatTab();
        break;
      case "conversations":
        this.renderConversationsTab();
        break;
      case "research":
        await this.renderResearchTab();
        break;
      case "settings":
        this.renderSettingsTab();
        break;
    }
  }
  renderChatTab() {
    const topBar = this.contentContainer.createEl("div", { cls: "chat-top-bar modern" });
    const titleSection = topBar.createEl("div", { cls: "chat-title-section" });
    const activeSession = this.chatSessions.find((s) => s.id === this.activeSessionId);
    const titleEl = titleSection.createEl("div", {
      text: (activeSession == null ? void 0 : activeSession.title) || "New Conversation",
      cls: "conversation-title-display",
      title: "Click to rename"
    });
    titleEl.onclick = async () => {
      if (activeSession) {
        await this.renameConversation(activeSession);
      }
    };
    const controlsSection = topBar.createEl("div", { cls: "chat-controls-section" });
    const statusIndicator = controlsSection.createEl("div", { cls: "connection-status" });
    this.updateConnectionStatus(statusIndicator);
    const chatArea = this.contentContainer.createEl("div", { cls: "chat-area modern" });
    this.chatContentContainer = chatArea.createEl("div", { cls: "chat-content" });
    if (this.activeSessionId) {
      this.loadChatMessages(this.activeSessionId);
    } else {
      this.renderEmptyState();
    }
  }
  updateConnectionStatus(container) {
    container.empty();
    const isConnected = this.plugin.isAgentRunning || this.plugin.settings.remoteMode;
    const statusDot = container.createEl("span", { cls: "status-dot" });
    const statusText = container.createEl("span", { cls: "status-text" });
    if (isConnected) {
      statusDot.addClass("connected");
      statusText.setText("Connected");
      container.title = "Server connection active";
    } else {
      statusDot.addClass("disconnected");
      statusText.setText("Disconnected");
      container.title = "Not connected to server";
    }
    container.addClass("clickable");
    container.onclick = () => {
      this.showConnectionDetails();
    };
  }
  showConnectionDetails() {
    const lettaEndpoint = this.plugin.getLettaEndpointUrl();
    const isConnected = this.plugin.isAgentRunning || this.plugin.settings.remoteMode;
    const mode = this.plugin.settings.remoteMode ? "Remote" : "Local";
    const details = `
Connection Status: ${isConnected ? "Connected" : "Disconnected"}
Mode: ${mode}
Chat Endpoint: ${lettaEndpoint}

${isConnected ? "\u2713 Ready to chat with Letta" : "\u26A0 Start the Letta server to begin"}
    `.trim();
    new import_obsidian4.Notice(details, 5e3);
  }
  // Removed old tab methods (commands, tools, status)
  // These features are now available through:
  // - Commands: Obsidian command palette (Cmd+P)
  // - Tools: Automatically available via MCP
  // - Status: Inline in chat header
  async renderConversationsTab() {
    const conversationsArea = this.contentContainer.createEl("div", { cls: "conversations-area" });
    const header = conversationsArea.createEl("div", { cls: "conversations-header" });
    const createBtn = header.createEl("button", {
      text: "+ New Conversation",
      cls: "thoth-new-conversation-btn"
    });
    createBtn.onclick = async () => {
      await this.createNewSession();
      this.switchTab("chat");
    };
    const searchInput = conversationsArea.createEl("input", {
      type: "text",
      placeholder: "Search conversations...",
      cls: "thoth-conversation-search"
    });
    searchInput.oninput = () => {
      this.filterConversations(searchInput.value);
    };
    const conversationsListContainer = conversationsArea.createEl("div", { cls: "conversations-list-container" });
    await this.loadAndDisplayConversations(conversationsListContainer);
  }
  async loadAndDisplayAgents(container) {
    try {
      container.empty();
      const loadingEl = container.createEl("div", { text: "Loading agents...", cls: "loading" });
      const endpoint = this.plugin.getLettaEndpointUrl();
      const response = await fetch(`${endpoint}/v1/agents/`);
      loadingEl.remove();
      if (response.ok) {
        const data = await response.json();
        this.displayAgentsList(container, data.agents || []);
      } else {
        container.createEl("div", {
          text: "Failed to load agents. Agent system may not be available.",
          cls: "error-message"
        });
      }
    } catch (error) {
      container.empty();
      container.createEl("div", {
        text: `Error loading agents: ${error.message}`,
        cls: "error-message"
      });
    }
  }
  displayAgentsList(container, agents) {
    if (agents.length === 0) {
      container.createEl("div", {
        text: "No agents available. Create your first agent!",
        cls: "empty-state"
      });
      return;
    }
    const agentsList = container.createEl("div", { cls: "agents-list" });
    agents.forEach((agent) => {
      const agentCard = agentsList.createEl("div", { cls: "agent-card" });
      const agentHeader = agentCard.createEl("div", { cls: "agent-header" });
      agentHeader.createEl("h4", { text: `@${agent.name}` });
      const typeEl = agentHeader.createEl("span", {
        text: agent.type || "custom",
        cls: `agent-type agent-type-${agent.type || "custom"}`
      });
      agentCard.createEl("p", { text: agent.description, cls: "agent-description" });
      if (agent.capabilities && agent.capabilities.length > 0) {
        const capsList = agentCard.createEl("div", { cls: "agent-capabilities" });
        capsList.createEl("strong", { text: "Capabilities: " });
        capsList.createEl("span", { text: agent.capabilities.join(", ") });
      }
      const actions = agentCard.createEl("div", { cls: "agent-actions" });
      const useBtn = actions.createEl("button", {
        text: "Use Agent",
        cls: "use-agent-btn"
      });
      useBtn.onclick = () => {
        this.switchTab("chat");
        setTimeout(() => {
          const inputField = document.querySelector(".chat-input");
          if (inputField) {
            inputField.value = `@${agent.name} `;
            inputField.focus();
          }
        }, 100);
      };
      if (agent.type === "user") {
        const deleteBtn = actions.createEl("button", {
          text: "Delete",
          cls: "delete-agent-btn"
        });
        deleteBtn.onclick = () => {
          this.confirmDeleteAgent(agent.name);
        };
      }
    });
  }
  showCreateAgentDialog() {
    const description = prompt(
      'Describe the agent you want to create:\n\nExample: "Create a citation analysis agent that can extract and analyze references from research papers"'
    );
    if (description && description.trim()) {
      this.switchTab("chat");
      setTimeout(() => {
        const inputField = document.querySelector(".chat-input");
        if (inputField) {
          inputField.value = `Create an agent that ${description.trim()}`;
          const sendBtn = document.querySelector(".chat-send-btn");
          if (sendBtn && !sendBtn.disabled) {
            sendBtn.click();
          }
        }
      }, 100);
    }
  }
  async confirmDeleteAgent(agentName) {
    const sessionId = agentName;
    if (confirm(`Delete this conversation? This action cannot be undone.`)) {
      try {
        const endpoint = this.plugin.getLettaEndpointUrl();
        const response = await fetch(`${endpoint}/v1/conversations/${sessionId}`, {
          method: "DELETE"
        });
        if (response.ok) {
          this.chatSessions = this.chatSessions.filter((s) => s.id !== sessionId);
          if (this.activeSessionId === sessionId) {
            this.activeSessionId = null;
            this.plugin.settings.activeChatSessionId = null;
            await this.plugin.saveSettings();
          }
          await this.loadChatSessions();
          new import_obsidian4.Notice("Conversation deleted");
        } else {
          throw new Error("Failed to delete conversation");
        }
      } catch (error) {
        console.error("Error deleting conversation:", error);
        new import_obsidian4.Notice("Failed to delete conversation");
      }
    }
  }
  addStyles() {
    const style = document.createElement("style");
    style.textContent = `
      .thoth-chat-popup {
        border-radius: 12px !important;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3) !important;
      }

      /* Allow background interaction by making backdrop transparent and non-interactive */
      .modal-container:has(.thoth-chat-popup),
      .thoth-transparent-backdrop {
        background-color: transparent !important;
        pointer-events: none !important;
      }

      .modal-container:has(.thoth-chat-popup) .thoth-chat-popup,
      .thoth-transparent-backdrop .thoth-chat-popup {
        pointer-events: auto !important;
      }

      /* Fallback for browsers that don't support :has() */
      .modal-container .thoth-chat-popup {
        pointer-events: auto !important;
      }

      /* Mobile-specific styles */
      .thoth-mobile-modal {
        border-radius: 0 !important;
      }

      .thoth-mobile-modal .thoth-tab-button {
        padding: 12px 20px !important;
        font-size: 14px !important;
        min-height: 44px !important;
      }

      .thoth-mobile-modal .new-chat-btn.compact,
      .thoth-mobile-modal .toggle-sidebar-btn {
        min-height: 44px !important;
        min-width: 44px !important;
        padding: 12px !important;
        font-size: 14px !important;
      }

      .thoth-mobile-modal .session-selector {
        min-height: 44px !important;
        font-size: 14px !important;
        padding: 8px 12px !important;
      }

      .thoth-mobile-modal .thoth-command-button {
        min-height: 44px !important;
        padding: 16px 20px !important;
        font-size: 14px !important;
      }

      .thoth-mobile-modal .chat-input {
        min-height: 44px !important;
        font-size: 16px !important;
        padding: 12px 16px !important;
      }

      .thoth-mobile-modal .chat-send-btn {
        min-height: 44px !important;
        padding: 12px 20px !important;
        font-size: 14px !important;
      }

      .thoth-mobile-modal .session-action-btn {
        min-width: 32px !important;
        min-height: 32px !important;
        padding: 8px !important;
      }

      .multi-chat-container.compact {
        display: flex;
        flex-direction: column;
        height: 100%;
        gap: 0;
        padding: 0;
        overflow: hidden;
        user-select: text;
      }

      .thoth-tab-navigation {
        display: flex;
        background: var(--background-secondary);
        border-bottom: 1px solid var(--background-modifier-border);
        padding: 8px 12px 0 12px;
        gap: 4px;
        flex-shrink: 0;
        user-select: none;
      }

      .thoth-tab-button {
        padding: 8px 16px;
        background: transparent;
        border: none;
        border-radius: 6px 6px 0 0;
        cursor: pointer;
        color: var(--text-muted);
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s ease;
        border-bottom: 2px solid transparent;
      }

      .thoth-tab-button:hover {
        background: var(--background-modifier-hover);
        color: var(--text-normal);
      }

      .thoth-tab-button.active {
        background: var(--background-primary);
        color: var(--text-accent);
        border-bottom-color: var(--interactive-accent);
      }

      .tab-content-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow: hidden;
      }

      .chat-top-bar {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        border-bottom: 1px solid var(--background-modifier-border);
        background: var(--background-secondary);
        border-radius: 0 0 8px 8px;
        min-height: 40px;
        flex-shrink: 0;
        user-select: none;
      }

      .session-selector {
        flex: 1;
        padding: 4px 8px;
        border: 1px solid var(--background-modifier-border);
        border-radius: 4px;
        background: var(--background-primary);
        color: var(--text-normal);
        font-size: 12px;
        min-width: 0;
      }

      .new-chat-btn.compact {
        padding: 6px 10px;
        background: var(--interactive-accent);
        color: var(--text-on-accent);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        min-width: 32px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .toggle-sidebar-btn {
        padding: 6px 8px;
        background: var(--background-modifier-hover);
        border: 1px solid var(--background-modifier-border);
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        color: var(--text-muted);
        min-width: 32px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .toggle-sidebar-btn:hover {
        background: var(--background-modifier-hover-hover);
        color: var(--text-normal);
      }

      .chat-sidebar {
        position: absolute;
        top: 60px;
        left: 8px;
        right: 8px;
        background: var(--background-primary);
        border: 1px solid var(--background-modifier-border);
        border-radius: 8px;
        z-index: 10;
        max-height: 300px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
      }

      .chat-sidebar.collapsed {
        display: none;
      }

      .session-list.compact {
        padding: 8px;
        max-height: 280px;
        overflow-y: auto;
      }

      .session-item {
        padding: 6px 8px;
        margin-bottom: 2px;
        border-radius: 4px;
        cursor: pointer;
        border: 1px solid transparent;
        position: relative;
        font-size: 12px;
      }

      .session-item:hover {
        background: var(--background-modifier-hover);
      }

      .session-item.active {
        background: var(--interactive-accent-hover);
        border-color: var(--interactive-accent);
      }

      .session-title {
        font-weight: 500;
        font-size: 12px;
        margin-bottom: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .session-preview {
        font-size: 10px;
        color: var(--text-muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 80%;
      }

      .session-meta {
        font-size: 9px;
        color: var(--text-faint);
        margin-top: 2px;
        display: flex;
        justify-content: space-between;
      }

      .session-actions {
        position: absolute;
        top: 2px;
        right: 2px;
        opacity: 0;
        transition: opacity 0.2s;
        display: flex;
        gap: 2px;
      }

      .session-item:hover .session-actions {
        opacity: 1;
      }

      .session-action-btn {
        padding: 2px 4px;
        background: none;
        border: none;
        cursor: pointer;
        color: var(--text-muted);
        font-size: 10px;
        border-radius: 2px;
      }

      .session-action-btn:hover {
        color: var(--text-normal);
        background: var(--background-modifier-hover);
      }

      .chat-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow: hidden;
      }

      .chat-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 8px;
        gap: 8px;
        min-height: 0;
        overflow: hidden;
      }

      .chat-messages {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 8px;
        border: 1px solid var(--background-modifier-border);
        border-radius: 6px;
        background: var(--background-primary);
        min-height: 200px;
        max-height: none;
        scroll-behavior: smooth;
        scrollbar-width: thin;
        scrollbar-color: var(--scrollbar-thumb-bg) var(--scrollbar-bg);
        user-select: text;
        pointer-events: auto;
      }

      .chat-messages::-webkit-scrollbar {
        width: 6px;
      }

      .chat-messages::-webkit-scrollbar-track {
        background: var(--background-secondary);
        border-radius: 3px;
      }

      .chat-messages::-webkit-scrollbar-thumb {
        background: var(--text-muted);
        border-radius: 3px;
      }

      .chat-messages::-webkit-scrollbar-thumb:hover {
        background: var(--text-normal);
      }

      .chat-message {
        margin-bottom: 12px;
        padding: 8px 12px;
        border-radius: 8px;
        max-width: 85%;
        word-wrap: break-word;
        animation: fadeIn 0.3s ease-in-out;
        position: relative;
        user-select: text;
        pointer-events: auto;
        cursor: text;
      }

      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }

      .chat-message.user {
        background: var(--interactive-accent-hover);
        margin-left: auto;
        text-align: right;
      }

      .chat-message.assistant {
        background: var(--background-secondary);
        margin-right: auto;
      }

      .message-role {
        font-weight: 600;
        font-size: 10px;
        margin-bottom: 3px;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .message-content {
        line-height: 1.3;
        font-size: 12px;
        user-select: text;
        pointer-events: auto;
        cursor: text;
      }

      .chat-input-area {
        display: flex;
        gap: 6px;
        align-items: flex-end;
        flex-shrink: 0;
        pointer-events: auto !important;
      }

      .chat-input {
        flex: 1;
        min-height: 36px;
        max-height: 80px;
        resize: vertical;
        padding: 6px 8px;
        border-radius: 6px;
        border: 1px solid var(--background-modifier-border);
        background: var(--background-primary);
        font-size: 12px;
        line-height: 1.3;
        pointer-events: auto !important;
        cursor: text;
      }

      .chat-input:focus {
        outline: none;
        border-color: var(--interactive-accent);
        box-shadow: 0 0 0 1px var(--interactive-accent);
      }

      .chat-send-btn {
        padding: 6px 12px;
        background: var(--interactive-accent);
        color: var(--text-on-accent);
        border: none;
        border-radius: 6px;
        cursor: pointer;
        height: fit-content;
        font-size: 12px;
        font-weight: 500;
        min-height: 36px;
      }

      .chat-send-btn:hover {
        background: var(--interactive-accent-hover);
      }

      .chat-send-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        background: var(--text-muted);
      }

      .empty-chat {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: var(--text-muted);
        text-align: center;
        padding: 20px;
      }

      .empty-chat div:first-child {
        font-size: 32px;
        margin-bottom: 8px;
      }

      .empty-chat h3 {
        margin: 0 0 4px 0;
        font-size: 14px;
      }

      .empty-chat p {
        margin: 0;
        font-size: 11px;
        color: var(--text-faint);
      }

      /* Commands tab styles */
      .commands-area {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        height: 100%;
      }

      .thoth-command-section {
        margin-bottom: 24px;
        padding: 16px;
        border: 1px solid var(--background-modifier-border);
        border-radius: 8px;
        background: var(--background-secondary);
      }

      .thoth-command-section h3 {
        margin: 0 0 12px 0;
        color: var(--text-accent);
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .thoth-command-section p {
        margin: 0 0 16px 0;
        color: var(--text-muted);
        font-size: 14px;
      }

      .thoth-command-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
      }

      .thoth-command-button {
        padding: 12px 16px;
        border: 1px solid var(--background-modifier-border);
        background: var(--background-primary);
        color: var(--text-normal);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: left;
        font-size: 14px;
        line-height: 1.4;
      }

      .thoth-command-button:hover {
        background: var(--background-modifier-hover);
        border-color: var(--interactive-accent);
        transform: translateY(-1px);
      }

      .thoth-command-button:active {
        transform: translateY(0);
      }

      .command-title {
        font-weight: 600;
        margin-bottom: 4px;
      }

      .command-desc {
        font-size: 12px;
        color: var(--text-muted);
      }

      /* Tools tab styles */
      .tools-area {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        height: 100%;
      }

      /* Status tab styles */
      .status-area {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        height: 100%;
      }

      .status-section {
        margin-bottom: 24px;
        padding: 16px;
        border: 1px solid var(--background-modifier-border);
        border-radius: 8px;
        background: var(--background-secondary);
      }

      .status-section h3 {
        margin: 0 0 12px 0;
        color: var(--text-accent);
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .status-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid var(--background-modifier-border);
      }

      .status-item:last-child {
        border-bottom: none;
      }

      .status-label {
        font-weight: 500;
        color: var(--text-normal);
      }

      .status-value {
        color: var(--text-muted);
        font-size: 14px;
      }

      .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .status-online {
        background-color: var(--color-green);
      }

      .status-offline {
        background-color: var(--color-red);
      }

      .status-warning {
        background-color: var(--color-orange);
      }
    `;
    document.head.appendChild(style);
  }
  async loadChatSessions() {
    try {
      const endpoint = this.plugin.getLettaEndpointUrl();
      const agentId = await this.getOrCreateDefaultAgent();
      const response = await this.fetchWithTimeout(`${endpoint}/v1/conversations/?agent_id=${agentId}&limit=50`);
      if (response.ok) {
        const conversations = await response.json();
        this.chatSessions = conversations.map((conv) => ({
          id: conv.id,
          title: conv.summary || `Chat ${conv.id.slice(0, 8)}`,
          created_at: conv.created_at,
          updated_at: conv.updated_at || conv.created_at,
          is_active: conv.id === this.activeSessionId,
          message_count: conv.message_count || 0,
          last_message_preview: conv.last_message || "",
          metadata: { agent_id: conv.agent_id }
        }));
      } else {
        console.warn("Could not load chat sessions from server");
        this.chatSessions = [];
      }
    } catch (error) {
      console.warn("Failed to load chat sessions:", error);
      this.chatSessions = [];
    }
  }
  async getOrCreateDefaultAgent() {
    if (this.plugin.settings.lettaAgentId) {
      console.log("[MultiChatModal] Using cached agent ID:", this.plugin.settings.lettaAgentId);
      return this.plugin.settings.lettaAgentId;
    }
    console.log("[MultiChatModal] No cached agent ID, fetching from server...");
    try {
      const endpoint = this.plugin.getLettaEndpointUrl();
      const listResponse = await this.fetchWithTimeout(`${endpoint}/v1/agents/`);
      if (listResponse.ok) {
        const agents = await listResponse.json();
        console.log("[MultiChatModal] Found agents:", agents.map((a) => a.name));
        const thothAgent = agents.find((a) => a.name === "thoth_main_orchestrator");
        if (thothAgent) {
          this.plugin.settings.lettaAgentId = thothAgent.id;
          await this.plugin.saveSettings();
          console.log("[MultiChatModal] Cached agent ID for future use:", thothAgent.id);
          return thothAgent.id;
        }
        console.error("[MultiChatModal] thoth_main_orchestrator not found. Available agents:", agents.map((a) => a.name));
      }
      throw new Error("Thoth orchestrator agent not found. Please ensure the Thoth backend is running and has initialized agents.");
    } catch (error) {
      console.error("Failed to get Thoth agent:", error);
      throw error;
    }
  }
  renderSessionList() {
    var _a;
    this.updateSessionSelector();
    if (!((_a = this.sidebar) == null ? void 0 : _a.hasClass("collapsed"))) {
      this.sessionListContainer.empty();
      if (this.chatSessions.length === 0) {
        const emptyEl = this.sessionListContainer.createEl("div", {
          text: "No chat sessions yet",
          cls: "session-list-empty"
        });
        emptyEl.style.cssText = "text-align: center; color: var(--text-muted); padding: 20px; font-size: 11px;";
        return;
      }
      this.chatSessions.forEach((session) => {
        const sessionEl = this.sessionListContainer.createEl("div", {
          cls: `session-item ${session.id === this.activeSessionId ? "active" : ""}`
        });
        sessionEl.onclick = () => {
          this.switchToSession(session.id);
        };
        const actionsEl = sessionEl.createEl("div", { cls: "session-actions" });
        const editBtn = actionsEl.createEl("button", {
          text: "\u270F\uFE0F",
          cls: "session-action-btn",
          title: "Rename session"
        });
        editBtn.onclick = (e) => {
          e.stopPropagation();
          this.renameSession(session.id);
        };
        const deleteBtn = actionsEl.createEl("button", {
          text: "\u{1F5D1}\uFE0F",
          cls: "session-action-btn",
          title: "Delete session"
        });
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          this.deleteSession(session.id);
        };
        sessionEl.createEl("div", {
          text: session.title,
          cls: "session-title"
        });
        if (session.last_message_preview) {
          sessionEl.createEl("div", {
            text: session.last_message_preview,
            cls: "session-preview"
          });
        }
        const metaEl = sessionEl.createEl("div", { cls: "session-meta" });
        metaEl.createEl("span", { text: `${session.message_count} msgs` });
        const date = new Date(session.updated_at);
        metaEl.createEl("span", { text: date.toLocaleDateString() });
      });
    }
  }
  updateSessionSelector() {
    if (!this.sessionSelector)
      return;
    this.sessionSelector.empty();
    const defaultOption = this.sessionSelector.createEl("option", {
      value: "",
      text: "Select a chat..."
    });
    this.chatSessions.forEach((session) => {
      const option = this.sessionSelector.createEl("option", {
        value: session.id,
        text: session.title
      });
      if (session.id === this.activeSessionId) {
        option.selected = true;
      }
    });
    this.sessionSelector.createEl("option", {
      value: "new",
      text: "+ New Chat"
    });
  }
  async createNewSession(title) {
    try {
      let sessionTitle = title;
      if (!sessionTitle) {
        const now = new Date();
        const timeStr = now.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true });
        sessionTitle = `New Chat - ${timeStr}`;
      }
      const endpoint = this.plugin.getLettaEndpointUrl();
      const agentId = await this.getOrCreateDefaultAgent();
      const response = await fetch(`${endpoint}/v1/conversations/?agent_id=${agentId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({})
      });
      if (response.ok) {
        const conversation = await response.json();
        const newSession = {
          id: conversation.id,
          title: conversation.summary || sessionTitle,
          created_at: conversation.created_at,
          updated_at: conversation.created_at,
          is_active: true,
          message_count: 0,
          last_message_preview: "",
          metadata: { agent_id: conversation.agent_id }
        };
        this.chatSessions.unshift(newSession);
        this.renderSessionList();
        await this.switchToSession(newSession.id);
        this.closeSidebar();
        new import_obsidian4.Notice(`Created: ${sessionTitle}`);
      } else {
        const errorText = await response.text();
        console.error(`[MultiChatModal] Failed to create session: ${response.status}`, errorText);
        throw new Error(`Failed to create session: ${response.status} ${response.statusText}`);
      }
    } catch (error) {
      console.error("[MultiChatModal] Error creating session:", error);
      new import_obsidian4.Notice(`Failed to create new chat session: ${error.message}`);
    }
  }
  async switchToSession(sessionId) {
    this.activeSessionId = sessionId;
    this.plugin.settings.activeChatSessionId = sessionId;
    await this.plugin.saveSettings();
    this.renderSessionList();
    await this.loadChatMessages(sessionId);
    this.closeSidebar();
  }
  async loadChatMessages(sessionId) {
    this.chatContentContainer.empty();
    try {
      const endpoint = this.plugin.getLettaEndpointUrl();
      const response = await fetch(`${endpoint}/v1/conversations/${sessionId}/messages?limit=100`);
      if (response.ok) {
        const messages = await response.json();
        this.renderChatInterface(sessionId, messages || []);
      } else {
        throw new Error("Failed to load messages");
      }
    } catch (error) {
      console.error("Error loading messages:", error);
      this.renderChatInterface(sessionId, []);
    }
  }
  renderChatInterface(sessionId, messages) {
    this.chatContentContainer.empty();
    const messagesContainer = this.chatContentContainer.createEl("div", {
      cls: "chat-messages"
    });
    const chatMessages = messages.filter((msg) => {
      const messageType = msg.message_type || msg.type;
      if (messageType === "user_message" || messageType === "assistant_message") {
        return true;
      }
      const role = msg.role;
      if (role === "user" || role === "assistant") {
        return true;
      }
      return false;
    });
    if (chatMessages.length === 0) {
      this.createEmptyState(
        messagesContainer,
        "\u{1F4AC}",
        "Start a conversation",
        "Ask me anything about your research, papers, or knowledge base. I can help you discover papers, analyze citations, and more.",
        'Try: "Find recent papers on transformers"'
      );
    } else {
      chatMessages.forEach((msg) => {
        const messageType = msg.message_type || msg.type;
        const role = messageType === "user_message" ? "user" : messageType === "assistant_message" ? "assistant" : msg.role;
        const content = msg.text || msg.content;
        this.addMessageToChat(messagesContainer, role, content);
      });
    }
    const inputArea = this.chatContentContainer.createEl("div", {
      cls: "chat-input-area"
    });
    const inputEl = inputArea.createEl("textarea", {
      cls: "chat-input",
      placeholder: "Type your message..."
    });
    inputArea.addEventListener("click", (e) => {
      if (e.target === inputArea) {
        inputEl.focus();
      }
    });
    const attachBtn = inputArea.createEl("button", {
      text: "\u{1F4CE}",
      cls: "chat-attach-btn",
      attr: { "aria-label": "Attach file", "title": "Attach file for context" }
    });
    attachBtn.onclick = (e) => {
      e.preventDefault();
      this.showAttachmentMenu(inputEl, e);
    };
    const sendBtn = inputArea.createEl("button", {
      text: "Send",
      cls: "chat-send-btn"
    });
    const sendMessage = async () => {
      const message = inputEl.value.trim();
      if (!message || sendBtn.disabled)
        return;
      this.addMessageToChat(messagesContainer, "user", message);
      inputEl.value = "";
      inputEl.style.height = "36px";
      sendBtn.disabled = true;
      sendBtn.textContent = "Sending...";
      const thinkingMsg = this.addThinkingIndicator(messagesContainer);
      try {
        const endpoint = this.plugin.getLettaEndpointUrl();
        const response = await fetch(`${endpoint}/v1/conversations/${sessionId}/messages`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            input: message,
            stream: true,
            // Enable streaming for real-time token display
            stream_tokens: true
            // Stream individual tokens
          })
        });
        if (response.ok && response.body) {
          thinkingMsg.remove();
          const messageAccumulator = /* @__PURE__ */ new Map();
          let assistantMessageEl = null;
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";
          while (true) {
            const { done, value } = await reader.read();
            if (done)
              break;
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n\n");
            buffer = lines.pop() || "";
            for (const line of lines) {
              if (!line.trim().startsWith("data:"))
                continue;
              const jsonStr = line.replace(/^data:\s*/, "").trim();
              if (!jsonStr || jsonStr === "[DONE]")
                continue;
              try {
                const msg = JSON.parse(jsonStr);
                if (msg.message_type === "assistant_message") {
                  const messageId = msg.id;
                  const delta = msg.content || msg.text || "";
                  if (delta && messageId) {
                    const existing = messageAccumulator.get(messageId) || "";
                    messageAccumulator.set(messageId, existing + delta);
                    const fullContent = messageAccumulator.get(messageId) || "";
                    if (!assistantMessageEl) {
                      assistantMessageEl = messagesContainer.createEl("div", {
                        cls: "chat-message assistant"
                      });
                      assistantMessageEl.createEl("div", {
                        text: "Assistant",
                        cls: "message-role"
                      });
                      assistantMessageEl.createEl("div", {
                        text: "",
                        cls: "message-content"
                      });
                    }
                    const contentEl = assistantMessageEl.querySelector(".message-content");
                    if (contentEl) {
                      contentEl.textContent = fullContent;
                    }
                    this.scrollToBottom(messagesContainer, true);
                  }
                }
              } catch (e) {
                console.warn("[MultiChatModal] Failed to parse SSE message:", jsonStr.substring(0, 100));
              }
            }
          }
          await this.loadChatSessions();
          this.renderSessionList();
        } else {
          const errorBody = await response.text();
          console.error(`[MultiChatModal] Message send failed: ${response.status}`, errorBody);
          throw new Error(`Failed to send message: ${response.status}`);
        }
      } catch (error) {
        console.error("Chat error:", error);
        thinkingMsg.remove();
        this.addMessageToChat(messagesContainer, "assistant", `Error: ${error.message}`);
        this.showToast(`Error: ${error.message}`, "error");
      } finally {
        sendBtn.disabled = false;
        sendBtn.textContent = "Send";
        inputEl.focus();
      }
    };
    sendBtn.onclick = sendMessage;
    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      } else if (e.key === "Escape") {
        inputEl.value = "";
        inputEl.style.height = "36px";
      }
    });
    inputEl.addEventListener("input", () => {
      inputEl.style.height = "36px";
      inputEl.style.height = Math.min(inputEl.scrollHeight, 80) + "px";
    });
    setTimeout(() => {
      inputEl.style.pointerEvents = "auto";
      inputEl.tabIndex = 0;
      inputEl.focus();
      setTimeout(() => {
        if (document.activeElement !== inputEl) {
          inputEl.focus();
        }
      }, 50);
      this.scrollToBottom(messagesContainer, false);
    }, 100);
  }
  addMessageToChat(container, role, content) {
    const messageEl = container.createEl("div", {
      cls: `chat-message ${role}`
    });
    messageEl.createEl("div", {
      text: role === "user" ? "You" : "Assistant",
      cls: "message-role"
    });
    const contentEl = messageEl.createEl("div", {
      text: content,
      cls: "message-content"
    });
    setTimeout(() => {
      this.scrollToBottom(container);
    }, 100);
  }
  scrollToBottom(container, smooth = true) {
    if (smooth) {
      container.scrollTo({
        top: container.scrollHeight,
        behavior: "smooth"
      });
    } else {
      container.scrollTop = container.scrollHeight;
    }
  }
  renderEmptyState() {
    this.chatContentContainer.empty();
    const emptyEl = this.chatContentContainer.createEl("div", {
      cls: "empty-chat"
    });
    emptyEl.createEl("div", { text: "\u{1F4AC}" });
    emptyEl.createEl("h3", { text: "No chat selected" });
    emptyEl.createEl("p", { text: "Select a chat from the dropdown or create a new one" });
  }
  async renameSession(sessionId) {
    const session = this.chatSessions.find((s) => s.id === sessionId);
    if (!session)
      return;
    const newTitle = await new Promise((resolve) => {
      const modal = new (init_input_modal(), __toCommonJS(input_modal_exports)).InputModal(
        this.plugin.app,
        "Enter new session name:",
        resolve,
        session.title
        // Default value
      );
      modal.open();
    });
    if (!newTitle || newTitle === session.title)
      return;
    try {
      const endpoint = this.plugin.getLettaEndpointUrl();
      const response = await fetch(`${endpoint}/v1/conversations/${sessionId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ summary: newTitle })
      });
      if (response.ok) {
        session.title = newTitle;
        this.renderSessionList();
        new import_obsidian4.Notice("Session renamed");
      } else {
        throw new Error("Failed to rename session");
      }
    } catch (error) {
      console.error("Error renaming session:", error);
      new import_obsidian4.Notice("Failed to rename session");
    }
  }
  detectAgentInteraction(message) {
    const messageLower = message.toLowerCase();
    const creationPatterns = [
      /create.*agent/i,
      /make.*agent/i,
      /build.*agent/i,
      /new.*agent/i,
      /add.*agent/i
    ];
    const hasCreationPattern = creationPatterns.some((pattern) => pattern.test(message));
    const agentMentions = /@([a-z][-a-z]*[a-z]|[a-z]+)/gi.test(message);
    const listPatterns = [
      /list.*agents?/i,
      /show.*agents?/i,
      /what.*agents?/i,
      /available.*agents?/i,
      /my.*agents?/i
    ];
    const hasListPattern = listPatterns.some((pattern) => pattern.test(message));
    return hasCreationPattern || agentMentions || hasListPattern;
  }
  async deleteSession(sessionId) {
    const session = this.chatSessions.find((s) => s.id === sessionId);
    if (!session)
      return;
    const confirmed = await new Promise((resolve) => {
      const modal = new (init_input_modal(), __toCommonJS(input_modal_exports)).InputModal(
        this.plugin.app,
        `Delete "${session.title}"? Type "DELETE" to confirm:`,
        (result) => resolve(result === "DELETE")
      );
      modal.open();
    });
    if (!confirmed)
      return;
    try {
      const endpoint = this.plugin.getLettaEndpointUrl();
      const response = await fetch(`${endpoint}/v1/conversations/${sessionId}`, {
        method: "DELETE"
      });
      if (response.ok) {
        this.chatSessions = this.chatSessions.filter((s) => s.id !== sessionId);
        if (this.activeSessionId === sessionId) {
          this.activeSessionId = null;
          this.plugin.settings.activeChatSessionId = null;
          await this.plugin.saveSettings();
          this.renderEmptyState();
        }
        this.renderSessionList();
        new import_obsidian4.Notice("Session deleted");
      } else {
        throw new Error("Failed to delete session");
      }
    } catch (error) {
      console.error("Error deleting session:", error);
      new import_obsidian4.Notice("Failed to delete session");
    }
  }
  // Commands tab functionality (integrated from CommandsModal)
  createAgentCommands(contentEl) {
    const section = contentEl.createEl("div", { cls: "thoth-command-section" });
    section.createEl("h3").innerHTML = "\u{1F916} Agent Management";
    section.createEl("p", { text: "Control the Thoth research agent" });
    const commandGrid = section.createEl("div", { cls: "thoth-command-grid" });
    const commands = [
      {
        title: "Start Agent",
        desc: "Launch the research agent",
        action: () => this.plugin.startAgent()
      },
      {
        title: "Stop Agent",
        desc: "Stop the research agent",
        action: () => this.plugin.stopAgent()
      },
      {
        title: "Restart Agent",
        desc: "Restart the research agent",
        action: () => this.plugin.restartAgent()
      },
      {
        title: "Agent Health Check",
        desc: "Check agent status and health",
        action: () => this.runHealthCheck()
      }
    ];
    commands.forEach((cmd) => {
      const button = commandGrid.createEl("div", { cls: "thoth-command-button" });
      button.createEl("div", { text: cmd.title, cls: "command-title" });
      button.createEl("div", { text: cmd.desc, cls: "command-desc" });
      button.onclick = () => {
        cmd.action();
        new import_obsidian4.Notice(`Executed: ${cmd.title}`);
      };
    });
  }
  createDiscoveryCommands(contentEl) {
    const section = contentEl.createEl("div", { cls: "thoth-command-section" });
    section.createEl("h3").innerHTML = "\u{1F50D} Discovery System";
    section.createEl("p", { text: "Manage content discovery and indexing" });
    const commandGrid = section.createEl("div", { cls: "thoth-command-grid" });
    const commands = [
      {
        title: "Start Discovery",
        desc: "Begin automated content discovery",
        action: () => this.runDiscoveryCommand("start")
      },
      {
        title: "Stop Discovery",
        desc: "Stop content discovery process",
        action: () => this.runDiscoveryCommand("stop")
      },
      {
        title: "Discovery Status",
        desc: "Check discovery system status",
        action: () => this.runDiscoveryCommand("status")
      },
      {
        title: "Add Discovery Source",
        desc: "Add new content source",
        action: () => this.plugin.openDiscoverySourceModal()
      }
    ];
    commands.forEach((cmd) => {
      const button = commandGrid.createEl("div", { cls: "thoth-command-button" });
      button.createEl("div", { text: cmd.title, cls: "command-title" });
      button.createEl("div", { text: cmd.desc, cls: "command-desc" });
      button.onclick = () => {
        cmd.action();
        new import_obsidian4.Notice(`Executed: ${cmd.title}`);
      };
    });
  }
  createDataCommands(contentEl) {
    const section = contentEl.createEl("div", { cls: "thoth-command-section" });
    section.createEl("h3").innerHTML = "\u{1F4CA} Data Management";
    section.createEl("p", { text: "Manage knowledge base and data" });
    const commandGrid = section.createEl("div", { cls: "thoth-command-grid" });
    const commands = [
      {
        title: "Rebuild Index",
        desc: "Rebuild the knowledge base index",
        action: () => this.runDataCommand("rebuild-index")
      },
      {
        title: "Clear Cache",
        desc: "Clear system caches",
        action: () => this.runDataCommand("clear-cache")
      },
      {
        title: "Export Data",
        desc: "Export knowledge base data",
        action: () => this.runDataCommand("export")
      },
      {
        title: "Backup Data",
        desc: "Create system backup",
        action: () => this.runDataCommand("backup")
      }
    ];
    commands.forEach((cmd) => {
      const button = commandGrid.createEl("div", { cls: "thoth-command-button" });
      button.createEl("div", { text: cmd.title, cls: "command-title" });
      button.createEl("div", { text: cmd.desc, cls: "command-desc" });
      button.onclick = () => {
        cmd.action();
        new import_obsidian4.Notice(`Executed: ${cmd.title}`);
      };
    });
  }
  createSystemCommands(contentEl) {
    const section = contentEl.createEl("div", { cls: "thoth-command-section" });
    section.createEl("h3").innerHTML = "\u2699\uFE0F System Operations";
    section.createEl("p", { text: "System-level operations and utilities" });
    const commandGrid = section.createEl("div", { cls: "thoth-command-grid" });
    const commands = [
      {
        title: "System Status",
        desc: "View comprehensive system status",
        action: () => this.openSystemStatus()
      },
      {
        title: "View Logs",
        desc: "Open system logs",
        action: () => this.runSystemCommand("logs")
      },
      {
        title: "Test Connection",
        desc: "Test server connectivity",
        action: () => this.runSystemCommand("test-connection")
      },
      {
        title: "Reset Settings",
        desc: "Reset to default settings",
        action: () => this.confirmResetSettings()
      }
    ];
    commands.forEach((cmd) => {
      const button = commandGrid.createEl("div", { cls: "thoth-command-button" });
      button.createEl("div", { text: cmd.title, cls: "command-title" });
      button.createEl("div", { text: cmd.desc, cls: "command-desc" });
      button.onclick = () => {
        cmd.action();
        new import_obsidian4.Notice(`Executed: ${cmd.title}`);
      };
    });
  }
  async runHealthCheck() {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(`${endpoint}/health`);
      if (response.ok) {
        const data = await response.json();
        new import_obsidian4.Notice(`Agent Health: ${data.status || "OK"}`);
      } else {
        new import_obsidian4.Notice("Agent health check failed", 3e3);
      }
    } catch (error) {
      new import_obsidian4.Notice("Could not connect to agent", 3e3);
    }
  }
  async runDiscoveryCommand(command) {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(`${endpoint}/execute/command`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          command: "discovery",
          args: [command]
        })
      });
      if (response.ok) {
        const result = await response.json();
        new import_obsidian4.Notice(`Discovery ${command}: ${result.message || "Success"}`);
      } else {
        throw new Error(`Discovery ${command} failed`);
      }
    } catch (error) {
      new import_obsidian4.Notice(`Discovery ${command} failed: ${error.message}`, 3e3);
    }
  }
  async runDataCommand(command) {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(`${endpoint}/execute/command`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          command: "data",
          args: [command]
        })
      });
      if (response.ok) {
        const result = await response.json();
        new import_obsidian4.Notice(`Data ${command}: ${result.message || "Success"}`);
      } else {
        throw new Error(`Data ${command} failed`);
      }
    } catch (error) {
      new import_obsidian4.Notice(`Data ${command} failed: ${error.message}`, 3e3);
    }
  }
  async runSystemCommand(command) {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(`${endpoint}/execute/command`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          command: "system",
          args: [command]
        })
      });
      if (response.ok) {
        const result = await response.json();
        new import_obsidian4.Notice(`System ${command}: ${result.message || "Success"}`);
      } else {
        throw new Error(`System ${command} failed`);
      }
    } catch (error) {
      new import_obsidian4.Notice(`System ${command} failed: ${error.message}`, 3e3);
    }
  }
  openSystemStatus() {
    this.switchTab("status");
    new import_obsidian4.Notice("Switched to Status tab");
  }
  async confirmResetSettings() {
    const confirmed = await this.plugin.showConfirm("Reset all settings to defaults? This cannot be undone.");
    if (confirmed) {
      new import_obsidian4.Notice("Settings reset to defaults");
    }
  }
  // Tools tab functionality
  createCitationTools(contentEl) {
    const section = contentEl.createEl("div", { cls: "thoth-command-section" });
    section.createEl("h3").innerHTML = "\u{1F4DD} Citation Tools";
    section.createEl("p", { text: "Tools for managing citations and references" });
    const commandGrid = section.createEl("div", { cls: "thoth-command-grid" });
    const tools = [
      {
        title: "Citation Inserter",
        desc: "Insert formatted citations into your notes",
        action: () => this.openCitationInserter()
      },
      {
        title: "Reference Manager",
        desc: "Manage your reference library",
        action: () => this.openReferenceManager()
      },
      {
        title: "Auto-Cite Selection",
        desc: "Automatically cite selected text",
        action: () => this.autoCiteSelection()
      },
      {
        title: "Export Bibliography",
        desc: "Export bibliography in various formats",
        action: () => this.exportBibliography()
      }
    ];
    tools.forEach((tool) => {
      const button = commandGrid.createEl("div", { cls: "thoth-command-button" });
      button.createEl("div", { text: tool.title, cls: "command-title" });
      button.createEl("div", { text: tool.desc, cls: "command-desc" });
      button.onclick = () => {
        tool.action();
        new import_obsidian4.Notice(`Executed: ${tool.title}`);
      };
    });
  }
  createResearchTools(contentEl) {
    const section = contentEl.createEl("div", { cls: "thoth-command-section" });
    section.createEl("h3").innerHTML = "\u{1F52C} Research Tools";
    section.createEl("p", { text: "Advanced research and analysis tools" });
    const commandGrid = section.createEl("div", { cls: "thoth-command-grid" });
    const tools = [
      {
        title: "Research Assistant",
        desc: "Open the research assistant interface",
        action: () => this.openResearchAssistant()
      },
      {
        title: "Topic Explorer",
        desc: "Explore topics and connections",
        action: () => this.openTopicExplorer()
      },
      {
        title: "Source Discovery",
        desc: "Discover new relevant sources",
        action: () => this.openSourceDiscovery()
      },
      {
        title: "Concept Map",
        desc: "Generate concept maps from your notes",
        action: () => this.generateConceptMap()
      }
    ];
    tools.forEach((tool) => {
      const button = commandGrid.createEl("div", { cls: "thoth-command-button" });
      button.createEl("div", { text: tool.title, cls: "command-title" });
      button.createEl("div", { text: tool.desc, cls: "command-desc" });
      button.onclick = () => {
        tool.action();
        new import_obsidian4.Notice(`Executed: ${tool.title}`);
      };
    });
  }
  createUtilityTools(contentEl) {
    const section = contentEl.createEl("div", { cls: "thoth-command-section" });
    section.createEl("h3").innerHTML = "\u{1F6E0}\uFE0F Utility Tools";
    section.createEl("p", { text: "General utility and helper functions" });
    const commandGrid = section.createEl("div", { cls: "thoth-command-grid" });
    const tools = [
      {
        title: "Note Templates",
        desc: "Create notes from templates",
        action: () => this.openNoteTemplates()
      },
      {
        title: "Quick Actions",
        desc: "Access quick action menu",
        action: () => this.openQuickActions()
      },
      {
        title: "File Organization",
        desc: "Organize and manage files",
        action: () => this.openFileOrganizer()
      },
      {
        title: "Bulk Operations",
        desc: "Perform bulk operations on notes",
        action: () => this.openBulkOperations()
      }
    ];
    tools.forEach((tool) => {
      const button = commandGrid.createEl("div", { cls: "thoth-command-button" });
      button.createEl("div", { text: tool.title, cls: "command-title" });
      button.createEl("div", { text: tool.desc, cls: "command-desc" });
      button.onclick = () => {
        tool.action();
        new import_obsidian4.Notice(`Executed: ${tool.title}`);
      };
    });
  }
  // Tool action methods
  async openCitationInserter() {
    var _a;
    const activeLeaf = this.app.workspace.activeLeaf;
    if (((_a = activeLeaf == null ? void 0 : activeLeaf.view) == null ? void 0 : _a.getViewType()) === "markdown") {
      const editor = activeLeaf.view.editor;
      if (editor) {
        await this.plugin.openCitationInserter(editor);
      } else {
        new import_obsidian4.Notice("No active editor found");
      }
    } else {
      new import_obsidian4.Notice("Please open a markdown file first");
    }
  }
  openReferenceManager() {
    new import_obsidian4.Notice("Reference manager coming soon!");
  }
  autoCiteSelection() {
    var _a;
    const activeLeaf = this.app.workspace.activeLeaf;
    if (((_a = activeLeaf == null ? void 0 : activeLeaf.view) == null ? void 0 : _a.getViewType()) === "markdown") {
      const editor = activeLeaf.view.editor;
      if (editor) {
        const selection = editor.getSelection();
        if (selection) {
          new import_obsidian4.Notice(`Auto-citing: "${selection.substring(0, 50)}..."`);
        } else {
          new import_obsidian4.Notice("Please select text to cite");
        }
      }
    } else {
      new import_obsidian4.Notice("Please open a markdown file first");
    }
  }
  exportBibliography() {
    new import_obsidian4.Notice("Bibliography export coming soon!");
  }
  openResearchAssistant() {
    this.switchTab("chat");
    new import_obsidian4.Notice("Research assistant is available in the Chat tab");
  }
  openTopicExplorer() {
    new import_obsidian4.Notice("Topic explorer coming soon!");
  }
  openSourceDiscovery() {
    this.plugin.openDiscoverySourceCreator();
  }
  generateConceptMap() {
    new import_obsidian4.Notice("Concept map generation coming soon!");
  }
  openNoteTemplates() {
    new import_obsidian4.Notice("Note templates coming soon!");
  }
  openQuickActions() {
    this.switchTab("commands");
    new import_obsidian4.Notice("Quick actions are available in the Commands tab");
  }
  openFileOrganizer() {
    new import_obsidian4.Notice("File organizer coming soon!");
  }
  openBulkOperations() {
    new import_obsidian4.Notice("Bulk operations coming soon!");
  }
  // Status tab functionality
  createConnectionStatus(contentEl) {
    const section = contentEl.createEl("div", { cls: "status-section" });
    section.createEl("h3").innerHTML = "\u{1F517} Connection Status";
    const statusItems = [
      { label: "Thoth Server", value: "Connected", status: "online" },
      { label: "WebSocket", value: "Active", status: "online" },
      { label: "Last Ping", value: "< 1 min ago", status: "online" },
      { label: "API Version", value: "v1.2.3", status: "online" }
    ];
    statusItems.forEach((item) => {
      const statusItem = section.createEl("div", { cls: "status-item" });
      const labelContainer = statusItem.createEl("div", { cls: "status-label" });
      labelContainer.style.display = "flex";
      labelContainer.style.alignItems = "center";
      const indicator = labelContainer.createEl("div", {
        cls: `status-indicator status-${item.status}`
      });
      labelContainer.createEl("span", { text: item.label });
      statusItem.createEl("div", {
        text: item.value,
        cls: "status-value"
      });
    });
    const refreshBtn = section.createEl("button", {
      text: "\u{1F504} Refresh Status",
      cls: "thoth-command-button"
    });
    refreshBtn.style.marginTop = "12px";
    refreshBtn.onclick = () => {
      this.refreshConnectionStatus();
    };
  }
  createSystemInfo(contentEl) {
    var _a;
    const section = contentEl.createEl("div", { cls: "status-section" });
    section.createEl("h3").innerHTML = "\u{1F4BB} System Information";
    const sysInfo = [
      { label: "Plugin Version", value: "1.0.0" },
      { label: "Obsidian Version", value: ((_a = this.app.vault.config) == null ? void 0 : _a.version) || "Unknown" },
      { label: "Active Sessions", value: this.chatSessions.length.toString() },
      { label: "Cache Size", value: "N/A" },
      { label: "Uptime", value: "N/A" }
    ];
    sysInfo.forEach((item) => {
      const statusItem = section.createEl("div", { cls: "status-item" });
      statusItem.createEl("div", { text: item.label, cls: "status-label" });
      statusItem.createEl("div", { text: item.value, cls: "status-value" });
    });
  }
  createActivityLog(contentEl) {
    const section = contentEl.createEl("div", { cls: "status-section" });
    section.createEl("h3").innerHTML = "\u{1F4CB} Recent Activity";
    const activities = [
      { time: "2 min ago", action: "Chat session created" },
      { time: "5 min ago", action: "Health check completed" },
      { time: "10 min ago", action: "Connected to Thoth server" },
      { time: "15 min ago", action: "Plugin initialized" }
    ];
    activities.forEach((activity) => {
      const activityItem = section.createEl("div", { cls: "status-item" });
      activityItem.createEl("div", { text: activity.action, cls: "status-label" });
      activityItem.createEl("div", { text: activity.time, cls: "status-value" });
    });
    const clearBtn = section.createEl("button", {
      text: "\u{1F5D1}\uFE0F Clear Log",
      cls: "thoth-command-button"
    });
    clearBtn.style.marginTop = "12px";
    clearBtn.onclick = () => {
      new import_obsidian4.Notice("Activity log cleared");
    };
  }
  async refreshConnectionStatus() {
    new import_obsidian4.Notice("Refreshing connection status...");
    try {
      await this.runHealthCheck();
      if (this.currentTab === "status") {
        await this.renderTabContent();
      }
      new import_obsidian4.Notice("Status refreshed");
    } catch (error) {
      new import_obsidian4.Notice("Failed to refresh status");
    }
  }
  // Conversations tab methods
  async loadAndDisplayConversations(container) {
    try {
      container.empty();
      const loadingEl = container.createEl("div", { text: "Loading conversations...", cls: "loading" });
      await this.loadChatSessions();
      loadingEl.remove();
      if (this.chatSessions.length === 0) {
        this.createEmptyState(
          container,
          "\u{1F4DD}",
          "No conversations yet",
          "Start your first conversation to chat with Thoth and explore your research.",
          "+ New Conversation",
          () => this.createNewSession().then(() => this.switchTab("chat"))
        );
        return;
      }
      const sortedSessions = [...this.chatSessions].sort((a, b) => {
        const dateA = new Date(b.created_at || 0).getTime();
        const dateB = new Date(a.created_at || 0).getTime();
        return dateA - dateB;
      });
      sortedSessions.forEach((session) => {
        this.createConversationCard(container, session);
      });
    } catch (error) {
      container.empty();
      container.createEl("div", {
        text: `Error loading conversations: ${error.message}`,
        cls: "error-message"
      });
    }
  }
  createConversationCard(container, session) {
    const card = container.createEl("div", { cls: "thoth-conversation-card" });
    card.style.userSelect = "none";
    card.style.cursor = "pointer";
    if (session.id === this.activeSessionId) {
      card.addClass("active");
    }
    const titleEl = card.createEl("div", {
      text: session.title || "Untitled Conversation",
      cls: "thoth-card-title"
    });
    const metaEl = card.createEl("div", { cls: "thoth-card-meta" });
    const timeAgo = this.getTimeAgo(session.created_at);
    const messageCount = session.message_count || 0;
    metaEl.setText(`${timeAgo} \u2022 ${messageCount} message${messageCount !== 1 ? "s" : ""}`);
    card.onclick = async (e) => {
      if (e.target.tagName === "BUTTON") {
        return;
      }
      await this.switchToSession(session.id);
      this.switchTab("chat");
    };
    const actionsEl = card.createEl("div", { cls: "thoth-card-actions" });
    const renameBtn = actionsEl.createEl("button", {
      text: "\u270F\uFE0F",
      cls: "thoth-card-action",
      attr: { "aria-label": "Rename" }
    });
    renameBtn.onclick = async (e) => {
      e.stopPropagation();
      await this.renameConversation(session);
    };
    const deleteBtn = actionsEl.createEl("button", {
      text: "\u{1F5D1}\uFE0F",
      cls: "thoth-card-action delete",
      attr: { "aria-label": "Delete" }
    });
    deleteBtn.onclick = async (e) => {
      e.stopPropagation();
      await this.deleteConversation(session);
    };
  }
  getTimeAgo(dateString) {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 6e4);
    if (diffMins < 1)
      return "Just now";
    if (diffMins < 60)
      return `${diffMins} min ago`;
    const diffHours = Math.floor(diffMins / 60);
    if (diffHours < 24)
      return `${diffHours} hour${diffHours !== 1 ? "s" : ""} ago`;
    const diffDays = Math.floor(diffHours / 24);
    if (diffDays < 7)
      return `${diffDays} day${diffDays !== 1 ? "s" : ""} ago`;
    return date.toLocaleDateString();
  }
  async renameConversation(session) {
    const newTitle = await this.promptForInput("Rename Conversation", session.title || "");
    if (newTitle && newTitle !== session.title) {
      session.title = newTitle;
      await this.plugin.saveSettings();
      await this.renderTabContent();
    }
  }
  async deleteConversation(session) {
    const confirmed = confirm(`Delete conversation "${session.title || "Untitled"}"?`);
    if (confirmed) {
      this.chatSessions = this.chatSessions.filter((s) => s.id !== session.id);
      if (this.activeSessionId === session.id) {
        this.activeSessionId = null;
        if (this.chatSessions.length > 0) {
          await this.switchToSession(this.chatSessions[0].id);
        } else {
          await this.createNewSession();
        }
      }
      await this.plugin.saveSettings();
      await this.renderTabContent();
    }
  }
  filterConversations(query) {
    const cards = this.contentContainer.querySelectorAll(".thoth-conversation-card");
    const lowerQuery = query.toLowerCase();
    cards.forEach((card) => {
      var _a;
      const titleEl = card.querySelector(".thoth-card-title");
      const title = ((_a = titleEl == null ? void 0 : titleEl.textContent) == null ? void 0 : _a.toLowerCase()) || "";
      if (title.includes(lowerQuery)) {
        card.style.display = "";
      } else {
        card.style.display = "none";
      }
    });
  }
  async promptForInput(title, defaultValue = "") {
    return new Promise((resolve) => {
      const modal = new import_obsidian4.Modal(this.app);
      modal.titleEl.setText(title);
      const input = modal.contentEl.createEl("input", {
        type: "text",
        value: defaultValue
      });
      input.style.width = "100%";
      input.style.marginBottom = "10px";
      const buttonsEl = modal.contentEl.createEl("div");
      buttonsEl.style.display = "flex";
      buttonsEl.style.justifyContent = "flex-end";
      buttonsEl.style.gap = "10px";
      const cancelBtn = buttonsEl.createEl("button", { text: "Cancel" });
      cancelBtn.onclick = () => {
        modal.close();
        resolve(null);
      };
      const okBtn = buttonsEl.createEl("button", { text: "OK", cls: "mod-cta" });
      okBtn.onclick = () => {
        modal.close();
        resolve(input.value);
      };
      input.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          modal.close();
          resolve(input.value);
        }
      });
      modal.open();
      input.focus();
    });
  }
  // Research tab
  async renderResearchTab() {
    const researchArea = this.contentContainer.createEl("div", { cls: "research-area" });
    const researchTab = new ResearchTabComponent(researchArea, this.plugin);
    await researchTab.render();
  }
  // Settings tab
  renderSettingsTab() {
    const settingsArea = this.contentContainer.createEl("div", { cls: "settings-area" });
    const settingsTab = new SettingsTabComponent(settingsArea, this.plugin);
    settingsTab.render();
  }
  // Helper: Add thinking indicator
  addThinkingIndicator(container) {
    const msg = container.createEl("div", { cls: "message assistant thinking" });
    const content = msg.createEl("div", { cls: "message-content" });
    const indicator = content.createEl("div", { cls: "thinking-indicator" });
    indicator.createEl("span", { cls: "dot" });
    indicator.createEl("span", { cls: "dot" });
    indicator.createEl("span", { cls: "dot" });
    content.createEl("span", { text: "Thinking..." });
    container.scrollTop = container.scrollHeight;
    return msg;
  }
  // Helper: Show toast notification
  showToast(message, type = "info") {
    const toast = document.body.createEl("div", {
      cls: `thoth-toast thoth-toast-${type}`,
      text: message
    });
    setTimeout(() => {
      toast.addClass("thoth-toast-fade-out");
      setTimeout(() => toast.remove(), 300);
    }, 3e3);
  }
  // Helper: Create empty state
  createEmptyState(container, icon, title, description, actionText, actionCallback) {
    const emptyState = container.createEl("div", { cls: "thoth-empty-state" });
    emptyState.createEl("div", {
      cls: "empty-state-icon",
      text: icon
    });
    emptyState.createEl("h3", {
      cls: "empty-state-title",
      text: title
    });
    emptyState.createEl("p", {
      cls: "empty-state-description",
      text: description
    });
    if (actionText && actionCallback) {
      const actionBtn = emptyState.createEl("button", {
        cls: "empty-state-action",
        text: actionText
      });
      actionBtn.onclick = actionCallback;
    }
    return emptyState;
  }
  // Helper: Show attachment menu
  showAttachmentMenu(inputEl, event) {
    const menu = new import_obsidian4.Menu();
    menu.addItem((item) => {
      item.setTitle("\u{1F4C4} Attach note from vault").setIcon("document").onClick(() => {
        this.attachVaultFile(inputEl);
      });
    });
    menu.addItem((item) => {
      item.setTitle("\u{1F517} Attach current note").setIcon("link").onClick(() => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          const fileLink = `[[${activeFile.path}]]`;
          inputEl.value += `
${fileLink}
`;
          inputEl.focus();
        } else {
          new import_obsidian4.Notice("No active file");
        }
      });
    });
    menu.addItem((item) => {
      item.setTitle("\u{1F4CB} Paste clipboard").setIcon("clipboard").onClick(async () => {
        try {
          const text = await navigator.clipboard.readText();
          inputEl.value += `
${text}
`;
          inputEl.focus();
        } catch (error) {
          new import_obsidian4.Notice("Failed to read clipboard");
        }
      });
    });
    menu.showAtMouseEvent(event);
  }
  // Helper: Attach vault file
  async attachVaultFile(inputEl) {
    new import_obsidian4.Notice("File attachment: Type [[ to create a wiki link to any note in your vault");
    inputEl.value += "[[";
    inputEl.focus();
  }
};

// src/modals/commands-modal.ts
var import_obsidian5 = require("obsidian");
var CommandsModal = class extends import_obsidian5.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.modalEl.addClass("thoth-commands-modal");
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.addStyles();
    this.titleEl.setText("\u26A1 Thoth Commands");
    this.createAgentCommands(contentEl);
    this.createDiscoveryCommands(contentEl);
    this.createDataCommands(contentEl);
    this.createSystemCommands(contentEl);
  }
  addStyles() {
    const style = document.createElement("style");
    style.textContent = `
      .thoth-commands-modal {
        width: 70vw !important;
        max-width: 800px !important;
        height: 70vh !important;
        max-height: 600px !important;
      }

      .thoth-command-section {
        margin-bottom: 24px;
        padding: 16px;
        border: 1px solid var(--background-modifier-border);
        border-radius: 8px;
        background: var(--background-secondary);
      }

      .thoth-command-section h3 {
        margin: 0 0 12px 0;
        color: var(--text-accent);
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .thoth-command-section p {
        margin: 0 0 16px 0;
        color: var(--text-muted);
        font-size: 14px;
      }

      .thoth-command-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
      }

      .thoth-command-button {
        padding: 12px 16px;
        border: 1px solid var(--background-modifier-border);
        background: var(--background-primary);
        color: var(--text-normal);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: left;
        font-size: 14px;
        line-height: 1.4;
      }

      .thoth-command-button:hover {
        background: var(--background-modifier-hover);
        border-color: var(--interactive-accent);
        transform: translateY(-1px);
      }

      .thoth-command-button:active {
        transform: translateY(0);
      }

      .command-title {
        font-weight: 600;
        margin-bottom: 4px;
      }

      .command-desc {
        font-size: 12px;
        color: var(--text-muted);
      }
    `;
    document.head.appendChild(style);
  }
  createAgentCommands(contentEl) {
    const section = contentEl.createEl("div", { cls: "thoth-command-section" });
    section.createEl("h3").innerHTML = "\u{1F916} Agent Management";
    section.createEl("p", { text: "Control the Thoth research agent" });
    const commandGrid = section.createEl("div", { cls: "thoth-command-grid" });
    const commands = [
      {
        title: "Start Agent",
        desc: "Launch the research agent",
        action: () => this.plugin.startAgent()
      },
      {
        title: "Stop Agent",
        desc: "Stop the research agent",
        action: () => this.plugin.stopAgent()
      },
      {
        title: "Restart Agent",
        desc: "Restart the research agent",
        action: () => this.plugin.restartAgent()
      },
      {
        title: "Agent Health Check",
        desc: "Check agent status and health",
        action: () => this.runHealthCheck()
      }
    ];
    commands.forEach((cmd) => {
      const button = commandGrid.createEl("div", { cls: "thoth-command-button" });
      button.createEl("div", { text: cmd.title, cls: "command-title" });
      button.createEl("div", { text: cmd.desc, cls: "command-desc" });
      button.onclick = () => {
        cmd.action();
        new import_obsidian5.Notice(`Executed: ${cmd.title}`);
      };
    });
  }
  createDiscoveryCommands(contentEl) {
    const section = contentEl.createEl("div", { cls: "thoth-command-section" });
    section.createEl("h3").innerHTML = "\u{1F50D} Discovery System";
    section.createEl("p", { text: "Manage content discovery and indexing" });
    const commandGrid = section.createEl("div", { cls: "thoth-command-grid" });
    const commands = [
      {
        title: "Start Discovery",
        desc: "Begin automated content discovery",
        action: () => this.runDiscoveryCommand("start")
      },
      {
        title: "Stop Discovery",
        desc: "Stop content discovery process",
        action: () => this.runDiscoveryCommand("stop")
      },
      {
        title: "Discovery Status",
        desc: "Check discovery system status",
        action: () => this.runDiscoveryCommand("status")
      },
      {
        title: "Add Discovery Source",
        desc: "Add new content source",
        action: () => this.plugin.openDiscoverySourceModal()
      }
    ];
    commands.forEach((cmd) => {
      const button = commandGrid.createEl("div", { cls: "thoth-command-button" });
      button.createEl("div", { text: cmd.title, cls: "command-title" });
      button.createEl("div", { text: cmd.desc, cls: "command-desc" });
      button.onclick = () => {
        cmd.action();
        new import_obsidian5.Notice(`Executed: ${cmd.title}`);
      };
    });
  }
  createDataCommands(contentEl) {
    const section = contentEl.createEl("div", { cls: "thoth-command-section" });
    section.createEl("h3").innerHTML = "\u{1F4CA} Data Management";
    section.createEl("p", { text: "Manage knowledge base and data" });
    const commandGrid = section.createEl("div", { cls: "thoth-command-grid" });
    const commands = [
      {
        title: "Rebuild Index",
        desc: "Rebuild the knowledge base index",
        action: () => this.runDataCommand("rebuild-index")
      },
      {
        title: "Clear Cache",
        desc: "Clear system caches",
        action: () => this.runDataCommand("clear-cache")
      },
      {
        title: "Export Data",
        desc: "Export knowledge base data",
        action: () => this.runDataCommand("export")
      },
      {
        title: "Backup Data",
        desc: "Create system backup",
        action: () => this.runDataCommand("backup")
      }
    ];
    commands.forEach((cmd) => {
      const button = commandGrid.createEl("div", { cls: "thoth-command-button" });
      button.createEl("div", { text: cmd.title, cls: "command-title" });
      button.createEl("div", { text: cmd.desc, cls: "command-desc" });
      button.onclick = () => {
        cmd.action();
        new import_obsidian5.Notice(`Executed: ${cmd.title}`);
      };
    });
  }
  createSystemCommands(contentEl) {
    const section = contentEl.createEl("div", { cls: "thoth-command-section" });
    section.createEl("h3").innerHTML = "\u2699\uFE0F System Operations";
    section.createEl("p", { text: "System-level operations and utilities" });
    const commandGrid = section.createEl("div", { cls: "thoth-command-grid" });
    const commands = [
      {
        title: "System Status",
        desc: "View comprehensive system status",
        action: () => this.openSystemStatus()
      },
      {
        title: "View Logs",
        desc: "Open system logs",
        action: () => this.runSystemCommand("logs")
      },
      {
        title: "Test Connection",
        desc: "Test server connectivity",
        action: () => this.runSystemCommand("test-connection")
      },
      {
        title: "Reset Settings",
        desc: "Reset to default settings",
        action: () => this.confirmResetSettings()
      }
    ];
    commands.forEach((cmd) => {
      const button = commandGrid.createEl("div", { cls: "thoth-command-button" });
      button.createEl("div", { text: cmd.title, cls: "command-title" });
      button.createEl("div", { text: cmd.desc, cls: "command-desc" });
      button.onclick = () => {
        cmd.action();
        new import_obsidian5.Notice(`Executed: ${cmd.title}`);
      };
    });
  }
  async runHealthCheck() {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(`${endpoint}/health`);
      if (response.ok) {
        const data = await response.json();
        new import_obsidian5.Notice(`Agent Health: ${data.status || "OK"}`);
      } else {
        new import_obsidian5.Notice("Agent health check failed", 3e3);
      }
    } catch (error) {
      new import_obsidian5.Notice("Could not connect to agent", 3e3);
    }
  }
  async runDiscoveryCommand(command) {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(`${endpoint}/execute/command`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          command: "discovery",
          args: [command]
        })
      });
      if (response.ok) {
        const result = await response.json();
        new import_obsidian5.Notice(`Discovery ${command}: ${result.message || "Success"}`);
      } else {
        throw new Error(`Discovery ${command} failed`);
      }
    } catch (error) {
      new import_obsidian5.Notice(`Discovery ${command} failed: ${error.message}`, 3e3);
    }
  }
  async runDataCommand(command) {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(`${endpoint}/execute/command`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          command: "data",
          args: [command]
        })
      });
      if (response.ok) {
        const result = await response.json();
        new import_obsidian5.Notice(`Data ${command}: ${result.message || "Success"}`);
      } else {
        throw new Error(`Data ${command} failed`);
      }
    } catch (error) {
      new import_obsidian5.Notice(`Data ${command} failed: ${error.message}`, 3e3);
    }
  }
  async runSystemCommand(command) {
    try {
      const endpoint = this.plugin.getEndpointUrl();
      const response = await fetch(`${endpoint}/execute/command`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          command: "system",
          args: [command]
        })
      });
      if (response.ok) {
        const result = await response.json();
        new import_obsidian5.Notice(`System ${command}: ${result.message || "Success"}`);
      } else {
        throw new Error(`System ${command} failed`);
      }
    } catch (error) {
      new import_obsidian5.Notice(`System ${command} failed: ${error.message}`, 3e3);
    }
  }
  openSystemStatus() {
    new import_obsidian5.Notice("System status feature coming soon!");
  }
  async confirmResetSettings() {
    const confirmed = await this.plugin.showConfirm("Reset all settings to defaults? This cannot be undone.");
    if (confirmed) {
      new import_obsidian5.Notice("Settings reset to defaults");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/index.ts
init_input_modal();

// src/modals/confirm-modal.ts
var import_obsidian6 = require("obsidian");
var ConfirmModal = class extends import_obsidian6.Modal {
  constructor(app, message, resolve) {
    super(app);
    this.message = message;
    this.resolve = resolve;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h3", { text: "Confirmation" });
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createEl("div");
    buttonContainer.style.cssText = "display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px;";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.style.cssText = "padding: 8px 16px; border: 1px solid var(--background-modifier-border); background: var(--background-secondary); border-radius: 4px;";
    cancelButton.onclick = () => {
      this.resolve(false);
      this.close();
    };
    const confirmButton = buttonContainer.createEl("button", { text: "Confirm" });
    confirmButton.style.cssText = "padding: 8px 16px; background: var(--interactive-accent); color: var(--text-on-accent); border: none; border-radius: 4px;";
    confirmButton.onclick = () => {
      this.resolve(true);
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var exec;
var spawn;
var ChildProcess;
if (typeof process !== "undefined" && !import_obsidian7.Platform.isMobile) {
  const cp = require("child_process");
  exec = cp.exec;
  spawn = cp.spawn;
  ChildProcess = cp.ChildProcess;
}
var execAsync = null;
function initDesktopUtils() {
  if (typeof process !== "undefined" && !import_obsidian7.Platform.isMobile && typeof require !== "undefined") {
    try {
      const util = require("util");
      execAsync = util.promisify(exec);
      return true;
    } catch (error) {
      console.warn("Desktop utilities not available:", error);
      return false;
    }
  }
  return false;
}
var ThothPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.process = null;
    // ChildProcess type only available on desktop
    this.isAgentRunning = false;
    this.isRestarting = false;
    this.socket = null;
    this.wsResolvers = /* @__PURE__ */ new Map();
    // Performance and caching
    this.requestCache = /* @__PURE__ */ new Map();
    this.requestQueue = [];
    this.isProcessingQueue = false;
    this.maxConcurrentRequests = 3;
    this.activeRequests = 0;
    this.cacheDefaultTTL = 3e5;
    this.floatingChatPanel = null;
    this.chatModalInstance = null;
    this.isMinimized = false;
    /**
     * Enhanced notification system with progress indicators and deduplication
     */
    this.notificationHistory = /* @__PURE__ */ new Map();
    this.activeProgressNotifications = /* @__PURE__ */ new Map();
    this.NOTIFICATION_COOLDOWN = 5e3;
    /**
     * Optimized settings save with debouncing
     */
    this.saveSettingsTimeout = null;
    /**
     * Performance monitoring and reporting
     */
    this.performanceMetrics = {
      requestCount: 0,
      averageResponseTime: 0,
      cacheHitRate: 0,
      errorRate: 0,
      startTime: Date.now()
    };
  }
  // 5 minutes
  async onload() {
    await this.loadSettings();
    initDesktopUtils();
    if (import_obsidian7.Platform.isMobile && !this.settings.remoteMode) {
      console.log("Thoth: Mobile device detected, enabling remote mode");
      this.settings.remoteMode = true;
      await this.saveSettings();
      if (!this.settings.remoteEndpointUrl) {
        new import_obsidian7.Notice("\u{1F4F1} Thoth: Mobile requires remote mode. Please configure your remote server URL in settings.", 8e3);
      }
    }
    const ribbonIconEl = this.addRibbonIcon("message-circle", "Open Thoth Chat", (evt) => {
      this.openChatModal();
    });
    ribbonIconEl.addClass("thoth-ribbon-icon");
    if (!import_obsidian7.Platform.isMobile) {
      this.addCommand({
        id: "start-thoth-agent",
        name: "Start Thoth Agent",
        callback: () => {
          this.startAgent();
        }
      });
      this.addCommand({
        id: "stop-thoth-agent",
        name: "Stop Thoth Agent",
        callback: () => {
          this.stopAgent();
        }
      });
      this.addCommand({
        id: "restart-thoth-agent",
        name: "Restart Thoth Agent",
        callback: () => {
          this.restartAgent();
        }
      });
    }
    this.addCommand({
      id: "open-research-chat",
      name: "Open Research Chat",
      callback: () => {
        this.openChatModal();
      }
    });
    this.registerCommands();
    this.addCommand({
      id: "insert-research-query",
      name: "Insert Research Query",
      editorCallback: (editor, view) => {
        const selectedText = editor.getSelection();
        if (selectedText) {
          this.performResearch(selectedText, editor);
        } else {
          new import_obsidian7.Notice("Please select text to research");
        }
      }
    });
    if (this.settings.showStatusBar) {
      this.statusBarItem = this.addStatusBarItem();
      this.updateStatusBar();
      this.statusBarItem.addEventListener("click", () => {
        if (this.isRestarting) {
          new import_obsidian7.Notice("Agent is currently restarting, please wait...");
          return;
        }
        if (this.isAgentRunning) {
          this.stopAgent();
        } else {
          this.startAgent();
        }
      });
    }
    this.addSettingTab(new ThothSettingTab(this.app, this));
    if (this.settings.autoStartAgent) {
      setTimeout(() => {
        this.startAgent();
      }, 2e3);
    }
  }
  async loadSettings() {
    const savedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, savedData);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getEndpointUrl() {
    const baseUrl = this.settings.remoteEndpointUrl || "http://localhost:8000";
    return baseUrl.replace(/\/$/, "");
  }
  getLettaEndpointUrl() {
    const baseUrl = this.settings.lettaEndpointUrl || "http://localhost:8284";
    return baseUrl.replace(/\/$/, "");
  }
  async startAgent() {
    var _a, _b;
    console.log("Thoth: startAgent called");
    console.log("Remote mode:", this.settings.remoteMode);
    console.log("Remote URL:", this.settings.remoteEndpointUrl);
    console.log("Endpoint URL:", this.getEndpointUrl());
    if (this.process && !this.settings.remoteMode) {
      new import_obsidian7.Notice("Thoth agent is already running");
      return;
    }
    if (this.settings.remoteMode) {
      if (!this.settings.remoteEndpointUrl) {
        new import_obsidian7.Notice("Please configure remote endpoint URL in settings");
        return;
      }
      new import_obsidian7.Notice("Connecting to remote Thoth server...");
      try {
        const endpointUrl = this.getEndpointUrl();
        console.log("Testing connection to:", endpointUrl);
        const response = await fetch(`${endpointUrl}/health`, {
          method: "GET",
          headers: {
            "Accept": "application/json"
          }
        });
        console.log("Health check response status:", response.status);
        if (response.ok) {
          const healthData = await response.json();
          console.log("Health check response:", healthData);
          this.isAgentRunning = true;
          this.updateStatusBar();
          new import_obsidian7.Notice("Connected to remote Thoth server successfully!");
          await this.connectWebSocket();
          return;
        } else {
          throw new Error(`Server responded with status: ${response.status}`);
        }
      } catch (error) {
        console.error("Failed to connect to remote server:", error);
        new import_obsidian7.Notice(`Failed to connect to remote server: ${error.message}`);
        return;
      }
    }
    const vaultPath = this.app.vault.adapter.basePath;
    new import_obsidian7.Notice("Starting Thoth agent...");
    try {
      const cmd = "uv";
      const args = [
        "run",
        "python",
        "-m",
        "thoth",
        "server",
        "--host",
        "localhost",
        "--port",
        "8000"
      ];
      const env = {
        ...process.env,
        OBSIDIAN_VAULT_PATH: vaultPath
      };
      this.process = spawn(cmd, args, {
        cwd: vaultPath,
        env,
        stdio: ["ignore", "pipe", "pipe"]
      });
      (_a = this.process.stdout) == null ? void 0 : _a.on("data", (data) => {
        console.log(`Thoth stdout: ${data}`);
      });
      (_b = this.process.stderr) == null ? void 0 : _b.on("data", (data) => {
        console.log(`Thoth stderr: ${data}`);
      });
      this.process.on("close", (code) => {
        console.log(`Thoth process exited with code ${code}`);
        this.process = null;
        this.isAgentRunning = false;
        this.updateStatusBar();
        if (code !== 0 && !this.isRestarting) {
          new import_obsidian7.Notice(`Thoth agent stopped with error code ${code}`);
        }
      });
      this.process.on("error", (error) => {
        console.error("Failed to start Thoth agent:", error);
        new import_obsidian7.Notice(`Failed to start Thoth agent: ${error.message}`);
        this.process = null;
        this.isAgentRunning = false;
        this.updateStatusBar();
      });
      setTimeout(async () => {
        if (this.process) {
          try {
            const response = await fetch(`${this.getEndpointUrl()}/health`);
            if (response.ok) {
              this.isAgentRunning = true;
              this.updateStatusBar();
              new import_obsidian7.Notice("Thoth agent started successfully!");
              await this.connectWebSocket();
            }
          } catch (error) {
            console.warn("Agent process started but server not yet responding");
            setTimeout(async () => {
              try {
                const response = await fetch(`${this.getEndpointUrl()}/health`);
                if (response.ok) {
                  this.isAgentRunning = true;
                  this.updateStatusBar();
                  new import_obsidian7.Notice("Thoth agent started successfully!");
                  await this.connectWebSocket();
                } else {
                  new import_obsidian7.Notice("Thoth agent started but not responding to requests");
                }
              } catch (error2) {
                new import_obsidian7.Notice("Thoth agent may have failed to start properly");
              }
            }, 5e3);
          }
        }
      }, 3e3);
    } catch (error) {
      console.error("Error starting Thoth agent:", error);
      new import_obsidian7.Notice(`Error starting Thoth agent: ${error.message}`);
    }
  }
  stopAgent() {
    if (this.settings.remoteMode) {
      this.disconnectWebSocket();
      this.isAgentRunning = false;
      this.updateStatusBar();
      new import_obsidian7.Notice("Disconnected from remote Thoth server");
      return;
    }
    if (!this.process) {
      new import_obsidian7.Notice("Thoth agent is not running");
      return;
    }
    this.process.kill("SIGTERM");
    setTimeout(() => {
      if (this.process) {
        this.process.kill("SIGKILL");
      }
    }, 5e3);
    this.process = null;
    this.isAgentRunning = false;
    this.disconnectWebSocket();
    this.updateStatusBar();
    new import_obsidian7.Notice("Thoth agent stopped");
  }
  async restartAgent() {
    if (this.isRestarting) {
      new import_obsidian7.Notice("Agent is already restarting, please wait...");
      return;
    }
    this.isRestarting = true;
    this.updateStatusBar();
    try {
      if (import_obsidian7.Platform.isMobile || this.getEndpointUrl().includes("http")) {
        new import_obsidian7.Notice("Remote server restart not supported. Please restart backend manually if needed.");
        this.isRestarting = false;
        this.updateStatusBar();
        return;
      } else {
        new import_obsidian7.Notice("Restarting Thoth agent...");
        this.stopAgent();
        await new Promise((resolve) => setTimeout(resolve, 2e3));
        await this.startAgent();
      }
      new import_obsidian7.Notice("Thoth agent restarted successfully!");
    } catch (error) {
      console.error("Failed to restart agent:", error);
      new import_obsidian7.Notice(`Failed to restart agent: ${error.message}`);
    } finally {
      this.isRestarting = false;
      this.updateStatusBar();
    }
  }
  async waitForAgentRestart() {
    const maxAttempts = 30;
    const interval = 1e3;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const endpoint = this.getEndpointUrl();
        const response = await fetch(`${endpoint}/health`);
        if (response.ok) {
          this.isAgentRunning = true;
          return;
        }
      } catch (error) {
      }
      await new Promise((resolve) => setTimeout(resolve, interval));
    }
    throw new Error("Agent did not become available after restart");
  }
  async connectWebSocket(retries = 3) {
    const wsUrl = this.getEndpointUrl().replace(/^http/, "ws") + "/ws/chat";
    for (let attempt = 0; attempt < retries; attempt++) {
      try {
        await new Promise((resolve, reject) => {
          const ws = new WebSocket(wsUrl);
          ws.onopen = () => {
            this.socket = ws;
            ws.onclose = () => {
              this.socket = null;
            };
            ws.onmessage = (event) => {
              let id;
              let text = event.data;
              try {
                const data = JSON.parse(event.data);
                id = data.id;
                text = data.response || event.data;
              } catch (e) {
              }
              if (id && this.wsResolvers.has(id)) {
                this.wsResolvers.get(id).resolve(text);
                this.wsResolvers.delete(id);
              }
            };
            ws.onerror = () => {
              this.wsResolvers.forEach(({ reject: reject2 }) => reject2(new Error("WebSocket error")));
              this.wsResolvers.clear();
            };
            resolve();
          };
          ws.onerror = () => {
            ws.close();
            reject(new Error("WebSocket error"));
          };
        });
        console.log("WebSocket connected");
        return;
      } catch (e) {
        console.warn(`WebSocket connection failed (attempt ${attempt + 1})`);
        await new Promise((r) => setTimeout(r, 1e3));
      }
    }
    console.warn("Unable to establish WebSocket connection");
  }
  disconnectWebSocket() {
    if (this.socket) {
      this.socket.close();
      this.socket = null;
      this.wsResolvers.forEach(({ reject }) => reject(new Error("WebSocket disconnected")));
      this.wsResolvers.clear();
    }
  }
  // REMOVED: getEnvironmentVariables() - Backend reads settings file directly
  // REMOVED: updateEnvironmentFile() - Backend reads settings file directly
  updateStatusBar() {
    if (!this.statusBarItem)
      return;
    if (this.isRestarting) {
      this.statusBarItem.setText("Thoth: Restarting...");
      this.statusBarItem.style.color = "#ffa500";
    } else if (this.isAgentRunning) {
      this.statusBarItem.setText("Thoth: Running");
      this.statusBarItem.style.color = "#00ff00";
    } else {
      this.statusBarItem.setText("Thoth: Stopped");
      this.statusBarItem.style.color = "#ff0000";
    }
  }
  async performResearch(query, editor) {
    if (!this.isAgentRunning) {
      new import_obsidian7.Notice("Thoth agent is not running. Please start it first.");
      return;
    }
    try {
      new import_obsidian7.Notice("Researching... This may take a moment.");
      const endpoint = this.getEndpointUrl();
      const response = await fetch(`${endpoint}/research/query`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          query,
          type: "quick_research",
          max_results: 5,
          include_citations: true
        })
      });
      if (response.ok) {
        const result = await response.json();
        const cursor = editor.getCursor();
        const researchText = `

## \u{1F50D} Research: ${query}
*Generated on ${new Date().toLocaleString()} by Thoth Research Assistant*

${result.response}

---
`;
        editor.replaceRange(researchText, cursor);
        new import_obsidian7.Notice("Research completed and inserted!");
      } else {
        throw new Error(`Research request failed: ${response.statusText}`);
      }
    } catch (error) {
      console.error("Research error:", error);
      new import_obsidian7.Notice(`Research failed: ${error.message}`);
    }
  }
  openChatModal() {
    if (this.app.isMobile) {
      new MultiChatModal(this.app, this).open();
    } else {
      if (this.floatingChatPanel) {
        if (this.floatingChatPanel.style.display === "none") {
          this.floatingChatPanel.style.display = "flex";
        } else {
          this.floatingChatPanel.style.display = "none";
        }
        return;
      }
      this.createFloatingChatPanel();
    }
  }
  createFloatingChatPanel() {
    this.floatingChatPanel = document.body.createEl("div", {
      cls: "thoth-floating-chat-panel"
    });
    this.floatingChatPanel.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 450px;
      height: 600px;
      max-width: 90vw;
      max-height: 80vh;
      z-index: 1000;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      background: var(--background-primary);
      border: 1px solid var(--background-modifier-border);
      resize: both;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      font-family: var(--font-interface);
    `;
    this.chatModalInstance = new MultiChatModal(this.app, this);
    this.chatModalInstance.contentEl = this.floatingChatPanel;
    this.chatModalInstance.modalEl = this.floatingChatPanel;
    this.initializeFloatingPanel();
  }
  async initializeFloatingPanel() {
    if (!this.chatModalInstance || !this.floatingChatPanel)
      return;
    const titleBar = this.floatingChatPanel.createEl("div", { cls: "thoth-title-bar" });
    const titleText = titleBar.createEl("span", { text: "\u{1F9E0} Thoth Chat" });
    titleText.style.flexGrow = "1";
    titleBar.style.cssText = `
      padding: 10px 15px;
      background: var(--background-secondary);
      border-bottom: 1px solid var(--background-modifier-border);
      border-radius: 12px 12px 0 0;
      cursor: move;
      user-select: none;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      gap: 8px;
    `;
    const buttonContainer = titleBar.createEl("div");
    buttonContainer.style.cssText = `
      display: flex;
      gap: 4px;
      align-items: center;
    `;
    const minimizeBtn = buttonContainer.createEl("button", { text: "_" });
    minimizeBtn.addClass("thoth-minimize-btn");
    minimizeBtn.title = "Minimize";
    minimizeBtn.style.cssText = `
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: var(--text-muted);
      padding: 0;
      width: 24px;
      height: 24px;
      font-weight: bold;
    `;
    minimizeBtn.onclick = () => this.toggleMinimize();
    const closeBtn = buttonContainer.createEl("button", { text: "\xD7" });
    closeBtn.style.cssText = `
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      color: var(--text-muted);
      padding: 0;
      width: 24px;
      height: 24px;
    `;
    closeBtn.onclick = () => this.closeFloatingPanel();
    const contentArea = this.floatingChatPanel.createEl("div", { cls: "thoth-panel-content" });
    contentArea.style.cssText = `
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    `;
    this.chatModalInstance.contentEl = contentArea;
    await this.chatModalInstance.onOpen();
    this.makeFloatingPanelDraggable();
  }
  toggleMinimize() {
    if (!this.floatingChatPanel)
      return;
    this.isMinimized = !this.isMinimized;
    if (this.isMinimized) {
      this.minimizePanel();
    } else {
      this.restorePanel();
    }
  }
  minimizePanel() {
    if (!this.floatingChatPanel)
      return;
    const originalWidth = this.floatingChatPanel.style.width || "450px";
    const originalHeight = this.floatingChatPanel.style.height || "600px";
    this.floatingChatPanel.dataset.originalWidth = originalWidth;
    this.floatingChatPanel.dataset.originalHeight = originalHeight;
    const contentArea = this.floatingChatPanel.querySelector(".thoth-panel-content");
    if (contentArea) {
      contentArea.style.display = "none";
    }
    const minimizedContent = this.floatingChatPanel.createEl("div", { cls: "thoth-minimized-content" });
    minimizedContent.style.cssText = `
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 12px;
      gap: 8px;
      min-height: 0;
    `;
    const responseArea = minimizedContent.createEl("div", { cls: "quick-response" });
    responseArea.style.cssText = `
      flex: 1;
      background: var(--background-secondary);
      border-radius: 6px;
      padding: 8px;
      font-size: 12px;
      overflow-y: auto;
      max-height: 60px;
      color: var(--text-muted);
      border: 1px solid var(--background-modifier-border);
    `;
    const lastMessage = this.getLastAssistantMessage();
    if (lastMessage) {
      responseArea.textContent = lastMessage.length > 150 ? lastMessage.substring(0, 150) + "..." : lastMessage;
    } else {
      responseArea.textContent = "Ask me anything... ";
      responseArea.style.fontStyle = "italic";
    }
    const quickInput = minimizedContent.createEl("div", { cls: "quick-input-area" });
    quickInput.style.cssText = `
      display: flex;
      gap: 6px;
      align-items: flex-end;
    `;
    const inputEl = quickInput.createEl("textarea", {
      placeholder: "Quick question..."
    });
    inputEl.style.cssText = `
      flex: 1;
      min-height: 32px;
      max-height: 60px;
      resize: vertical;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--background-modifier-border);
      background: var(--background-primary);
      font-size: 12px;
      line-height: 1.3;
    `;
    const sendBtn = quickInput.createEl("button", { text: "Ask" });
    sendBtn.style.cssText = `
      padding: 6px 12px;
      background: var(--interactive-accent);
      color: var(--text-on-accent);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      height: fit-content;
      font-size: 12px;
      font-weight: 500;
      min-height: 32px;
    `;
    const sendQuickMessage = async () => {
      const message = inputEl.value.trim();
      if (!message || sendBtn.disabled)
        return;
      responseArea.textContent = `You: ${message}`;
      responseArea.style.fontStyle = "normal";
      inputEl.value = "";
      sendBtn.disabled = true;
      sendBtn.textContent = "Asking...";
      try {
        if (this.chatModalInstance && this.chatModalInstance.activeSessionId) {
          const endpoint = this.getEndpointUrl();
          const response = await fetch(`${endpoint}/research/chat`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              message,
              conversation_id: this.chatModalInstance.activeSessionId,
              timestamp: Date.now(),
              id: crypto.randomUUID()
            })
          });
          if (response.ok) {
            const result = await response.json();
            const assistantResponse = result.response;
            responseArea.textContent = assistantResponse.length > 150 ? assistantResponse.substring(0, 150) + "..." : assistantResponse;
            if (this.chatModalInstance) {
              await this.chatModalInstance.loadChatSessions();
              this.chatModalInstance.renderSessionList();
            }
          } else {
            throw new Error("Failed to send message");
          }
        } else {
          throw new Error("No active chat session");
        }
      } catch (error) {
        console.error("Quick chat error:", error);
        responseArea.textContent = `Error: ${error.message}`;
      } finally {
        sendBtn.disabled = false;
        sendBtn.textContent = "Ask";
        inputEl.focus();
      }
    };
    sendBtn.onclick = sendQuickMessage;
    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendQuickMessage();
      }
    });
    this.floatingChatPanel.style.width = "400px";
    this.floatingChatPanel.style.height = "160px";
    this.floatingChatPanel.style.resize = "horizontal";
    const minimizeBtn = this.floatingChatPanel.querySelector(".thoth-minimize-btn");
    if (minimizeBtn) {
      minimizeBtn.textContent = "\u25A1";
      minimizeBtn.title = "Restore";
    }
    setTimeout(() => inputEl.focus(), 100);
  }
  restorePanel() {
    if (!this.floatingChatPanel)
      return;
    const minimizedContent = this.floatingChatPanel.querySelector(".thoth-minimized-content");
    if (minimizedContent) {
      minimizedContent.remove();
    }
    const contentArea = this.floatingChatPanel.querySelector(".thoth-panel-content");
    if (contentArea) {
      contentArea.style.display = "flex";
    }
    const originalWidth = this.floatingChatPanel.dataset.originalWidth || "450px";
    const originalHeight = this.floatingChatPanel.dataset.originalHeight || "600px";
    this.floatingChatPanel.style.width = originalWidth;
    this.floatingChatPanel.style.height = originalHeight;
    this.floatingChatPanel.style.resize = "both";
    const minimizeBtn = this.floatingChatPanel.querySelector(".thoth-minimize-btn");
    if (minimizeBtn) {
      minimizeBtn.textContent = "_";
      minimizeBtn.title = "Minimize";
    }
  }
  getLastAssistantMessage() {
    if (this.chatModalInstance && this.chatModalInstance.activeSessionId) {
      return null;
    }
    return null;
  }
  closeFloatingPanel() {
    if (this.floatingChatPanel) {
      this.floatingChatPanel.remove();
      this.floatingChatPanel = null;
    }
    if (this.chatModalInstance) {
      this.chatModalInstance.onClose();
      this.chatModalInstance = null;
    }
    this.isMinimized = false;
  }
  makeFloatingPanelDraggable() {
    if (!this.floatingChatPanel)
      return;
    const titleBar = this.floatingChatPanel.querySelector(".thoth-title-bar");
    let isDragging = false;
    let currentX = 0;
    let currentY = 0;
    let initialX = 0;
    let initialY = 0;
    let xOffset = 0;
    let yOffset = 0;
    titleBar.addEventListener("mousedown", dragStart);
    document.addEventListener("mousemove", drag);
    document.addEventListener("mouseup", dragEnd);
    const self = this;
    function dragStart(e) {
      if (e.target.tagName === "BUTTON")
        return;
      initialX = e.clientX - xOffset;
      initialY = e.clientY - yOffset;
      isDragging = true;
      self.floatingChatPanel.style.cursor = "grabbing";
    }
    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
        xOffset = currentX;
        yOffset = currentY;
        const rect = self.floatingChatPanel.getBoundingClientRect();
        const maxX = window.innerWidth - rect.width;
        const maxY = window.innerHeight - rect.height;
        currentX = Math.max(0, Math.min(currentX, maxX));
        currentY = Math.max(0, Math.min(currentY, maxY));
        self.floatingChatPanel.style.right = "unset";
        self.floatingChatPanel.style.bottom = "unset";
        self.floatingChatPanel.style.left = currentX + "px";
        self.floatingChatPanel.style.top = currentY + "px";
      }
    }
    function dragEnd() {
      initialX = currentX;
      initialY = currentY;
      isDragging = false;
      if (self.floatingChatPanel) {
        self.floatingChatPanel.style.cursor = "auto";
      }
    }
  }
  openDiscoverySourceModal() {
    new import_obsidian7.Notice("Discovery source modal not yet implemented");
  }
  async showConfirm(message) {
    return new Promise((resolve) => {
      new ConfirmModal(this.app, message, resolve).open();
    });
  }
  async showInput(prompt2) {
    return new Promise((resolve) => {
      new InputModal(this.app, prompt2, resolve).open();
    });
  }
  openCommandsModal() {
    new CommandsModal(this.app, this).open();
  }
  registerCommands() {
    this.addCommand({
      id: "thoth-discovery-list",
      name: "Thoth: List Discovery Sources",
      callback: () => {
        this.executeQuickCommand("discovery", ["list"]);
      }
    });
    this.addCommand({
      id: "thoth-discovery-run",
      name: "Thoth: Run Discovery",
      callback: () => {
        this.promptAndExecuteCommand("discovery", ["run"], "Enter source name (optional):");
      }
    });
    this.addCommand({
      id: "thoth-discovery-create",
      name: "Thoth: Create Discovery Source",
      callback: () => {
        this.openDiscoverySourceCreator();
      }
    });
    this.addCommand({
      id: "thoth-pdf-locate",
      name: "Thoth: Locate PDF",
      callback: () => {
        this.promptAndExecuteCommand("pdf-locate", [], "Enter DOI or paper identifier:");
      }
    });
    this.addCommand({
      id: "thoth-pdf-stats",
      name: "Thoth: PDF Statistics",
      callback: () => {
        this.executeQuickCommand("pdf-stats", []);
      }
    });
    this.addCommand({
      id: "thoth-pdf-process-current",
      name: "Thoth: Process Current PDF",
      callback: () => {
        this.processCurrentFile();
      }
    });
    this.addCommand({
      id: "thoth-rag-index",
      name: "Thoth: Index Knowledge Base",
      callback: () => {
        this.executeQuickCommand("rag", ["index"]);
      }
    });
    this.addCommand({
      id: "thoth-rag-search",
      name: "Thoth: Search Knowledge Base",
      callback: () => {
        this.promptAndExecuteCommand("rag", ["search"], "Enter search query:");
      }
    });
    this.addCommand({
      id: "thoth-rag-ask",
      name: "Thoth: Ask Knowledge Base",
      callback: () => {
        this.promptAndExecuteCommand("rag", ["ask"], "Enter your question:");
      }
    });
    this.addCommand({
      id: "thoth-rag-stats",
      name: "Thoth: RAG Statistics",
      callback: () => {
        this.executeQuickCommand("rag", ["stats"]);
      }
    });
    this.addCommand({
      id: "thoth-notes-regenerate",
      name: "Thoth: Regenerate All Notes",
      callback: () => {
        this.confirmAndExecuteCommand("notes", ["regenerate-all-notes"], "This will regenerate all notes. Continue?");
      }
    });
    this.addCommand({
      id: "thoth-notes-consolidate-tags",
      name: "Thoth: Consolidate Tags",
      callback: () => {
        this.executeQuickCommand("notes", ["consolidate-tags"]);
      }
    });
    this.addCommand({
      id: "thoth-notes-reprocess",
      name: "Thoth: Reprocess Current Note",
      callback: () => {
        this.reprocessCurrentNote();
      }
    });
    this.addCommand({
      id: "thoth-quick-research",
      name: "Thoth: Quick Research (Selected Text)",
      editorCallback: (editor, view) => {
        const selectedText = editor.getSelection();
        if (selectedText) {
          this.performQuickResearch(selectedText, editor);
        } else {
          new import_obsidian7.Notice("Please select text to research");
        }
      }
    });
    this.addCommand({
      id: "thoth-insert-citation",
      name: "Thoth: Insert Citation",
      editorCallback: (editor, view) => {
        this.openCitationInserter(editor);
      }
    });
    this.addCommand({
      id: "thoth-open-commands",
      name: "Thoth: Open Commands",
      callback: () => {
        this.openCommandsModal();
      }
    });
    this.addCommand({
      id: "thoth-open-status",
      name: "Thoth: Open Status",
      callback: () => {
        new import_obsidian7.Notice("Status modal coming soon! Use Commands modal for now.");
        this.openCommandsModal();
      }
    });
    this.addCommand({
      id: "thoth-toggle-agent",
      name: "Thoth: Toggle Agent (Start/Stop)",
      callback: () => {
        if (this.isAgentRunning) {
          this.stopAgent();
        } else {
          this.startAgent();
        }
      }
    });
    this.addCommand({
      id: "thoth-agent-health-check",
      name: "Thoth: Agent Health Check",
      callback: () => {
        this.performHealthCheck();
      }
    });
    this.addCommand({
      id: "thoth-validate-config",
      name: "Thoth: Validate Configuration",
      callback: () => {
        this.validateConfiguration();
      }
    });
  }
  async executeQuickCommand(command, args) {
    if (!this.isAgentRunning) {
      this.smartNotice("Thoth agent is not running. Please start it first.", "warning", 2);
      return;
    }
    const commandId = `cmd-${command}-${Date.now()}`;
    const progressNotification = this.createProgressNotification(
      commandId,
      `Executing ${command}...`,
      {
        type: "info",
        canCancel: true,
        onCancel: () => {
          this.smartNotice(`${command} operation cancelled`, "warning");
        }
      }
    );
    try {
      progressNotification.updateProgress(10, `Sending ${command} request...`);
      const endpoint = this.getEndpointUrl();
      const response = await fetch(`${endpoint}/execute/command`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          command,
          args,
          stream_output: true
        })
      });
      progressNotification.updateProgress(30, "Processing request...");
      if (response.ok) {
        const result = await response.json();
        if (result.streaming) {
          progressNotification.updateProgress(60, `${command} running...`);
          setTimeout(() => {
            progressNotification.updateProgress(80, "Finalizing...");
            setTimeout(() => {
              progressNotification.updateProgress(100, `${command} completed!`);
              progressNotification.setType("success");
              setTimeout(() => {
                progressNotification.close();
                this.smartNotice(`${command} completed successfully`, "success");
              }, 1500);
            }, 1e3);
          }, 2e3);
        } else {
          progressNotification.updateProgress(100, `${command} completed!`);
          progressNotification.setType("success");
          setTimeout(() => {
            progressNotification.close();
            this.smartNotice(`${command} completed successfully`, "success");
          }, 1500);
        }
      } else {
        throw new Error(`Command failed: ${response.statusText}`);
      }
    } catch (error) {
      console.error("Command execution error:", error);
      progressNotification.setType("error");
      progressNotification.updateMessage(`${command} failed: ${error.message}`);
      setTimeout(() => {
        progressNotification.close();
        this.smartNotice(`${command} execution failed`, "error", 3);
      }, 3e3);
    }
  }
  async promptAndExecuteCommand(command, baseArgs, promptText) {
    const input = await this.showInputPrompt(promptText);
    if (input) {
      const args = input ? [...baseArgs, ...input.split(" ")] : baseArgs;
      this.executeQuickCommand(command, args);
    }
  }
  async confirmAndExecuteCommand(command, args, confirmText) {
    const confirmed = await this.showConfirmDialog(confirmText);
    if (confirmed) {
      this.executeQuickCommand(command, args);
    }
  }
  async showInputPrompt(promptText) {
    return new Promise((resolve) => {
      const modal = new InputModal(this.app, promptText, resolve);
      modal.open();
    });
  }
  async showConfirmDialog(message) {
    return new Promise((resolve) => {
      const modal = new ConfirmModal(this.app, message, resolve);
      modal.open();
    });
  }
  async processCurrentFile() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian7.Notice("No active file");
      return;
    }
    if (!activeFile.path.endsWith(".pdf")) {
      new import_obsidian7.Notice("Current file is not a PDF");
      return;
    }
    try {
      const endpoint = this.getEndpointUrl();
      const response = await fetch(`${endpoint}/stream/operation`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          operation_type: "pdf_process",
          parameters: {
            pdf_paths: [activeFile.path]
          }
        })
      });
      if (response.ok) {
        const result = await response.json();
        new import_obsidian7.Notice(`Processing ${activeFile.name}. Check Thoth status for progress.`);
      } else {
        throw new Error(`PDF processing failed: ${response.statusText}`);
      }
    } catch (error) {
      console.error("PDF processing error:", error);
      new import_obsidian7.Notice(`PDF processing failed: ${error.message}`);
    }
  }
  async reprocessCurrentNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian7.Notice("No active file");
      return;
    }
    const articleId = this.extractArticleId(activeFile);
    if (!articleId) {
      new import_obsidian7.Notice("Could not determine article ID from current note");
      return;
    }
    this.executeQuickCommand("notes", ["reprocess-note", "--article-id", articleId]);
  }
  extractArticleId(file) {
    const basename = file.basename;
    const doiMatch = basename.match(/10\.\d{4,}\/[^\s]+/);
    if (doiMatch) {
      return doiMatch[0];
    }
    const arxivMatch = basename.match(/(\d{4}\.\d{4,5})/);
    if (arxivMatch) {
      return `arxiv:${arxivMatch[1]}`;
    }
    return basename;
  }
  async performQuickResearch(query, editor) {
    if (!this.isAgentRunning) {
      new import_obsidian7.Notice("Thoth agent is not running. Please start it first.");
      return;
    }
    try {
      new import_obsidian7.Notice("Researching... This may take a moment.");
      const endpoint = this.getEndpointUrl();
      const response = await fetch(`${endpoint}/research/query`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          query,
          type: "quick_research",
          max_results: 5,
          include_citations: true
        })
      });
      if (response.ok) {
        const result = await response.json();
        const cursor = editor.getCursor();
        const researchText = `

## \u{1F50D} Research: ${query}
*Generated on ${new Date().toLocaleString()} by Thoth Research Assistant*

${result.response || result.results}

---
`;
        editor.replaceRange(researchText, cursor);
        new import_obsidian7.Notice("Research completed and inserted!");
      } else {
        throw new Error(`Research request failed: ${response.statusText}`);
      }
    } catch (error) {
      console.error("Research error:", error);
      new import_obsidian7.Notice(`Research failed: ${error.message}`);
    }
  }
  async openCitationInserter(editor) {
    new import_obsidian7.Notice("Citation inserter not yet implemented");
  }
  async openDiscoverySourceCreator() {
    new import_obsidian7.Notice("Discovery source creator not yet implemented");
  }
  async performHealthCheck() {
    try {
      const endpoint = this.getEndpointUrl();
      const response = await fetch(`${endpoint}/health`);
      if (response.ok) {
        const health = await response.json();
        new import_obsidian7.Notice(`Health Check: ${health.status || "OK"}`);
      } else {
        new import_obsidian7.Notice(`Health Check Failed: ${response.statusText}`);
      }
    } catch (error) {
      new import_obsidian7.Notice(`Health Check Failed: ${error.message}`);
    }
  }
  async validateConfiguration() {
    try {
      const endpoint = this.getEndpointUrl();
      const response = await fetch(`${endpoint}/config/validate`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(this.settings)
      });
      if (response.ok) {
        const validation = await response.json();
        if (validation.is_valid) {
          new import_obsidian7.Notice("\u2705 Configuration is valid");
        } else {
          new import_obsidian7.Notice(`\u274C Configuration errors: ${validation.error_count}`);
          console.log("Validation errors:", validation.errors);
        }
      } else {
        new import_obsidian7.Notice("Configuration validation failed");
      }
    } catch (error) {
      new import_obsidian7.Notice(`Validation failed: ${error.message}`);
    }
  }
  // ============================================================================
  // PERFORMANCE & CACHING SYSTEM
  // ============================================================================
  /**
   * Cached HTTP request with automatic cache management
   */
  async cachedRequest(url, options = {}, ttl = this.cacheDefaultTTL) {
    const cacheKey = this.generateCacheKey(url, options);
    const cached = this.requestCache.get(cacheKey);
    if (cached && Date.now() < cached.expires) {
      return cached.data;
    }
    return this.queueRequest(async () => {
      const response = await fetch(url, options);
      if (!response.ok) {
        throw new Error(`Request failed: ${response.statusText}`);
      }
      const data = await response.json();
      this.requestCache.set(cacheKey, {
        data,
        timestamp: Date.now(),
        expires: Date.now() + ttl
      });
      return data;
    });
  }
  /**
   * Queue requests to prevent overwhelming the backend
   */
  async queueRequest(request) {
    return new Promise((resolve, reject) => {
      this.requestQueue.push({ request, resolve, reject });
      this.processQueue();
    });
  }
  /**
   * Process the request queue with concurrency control
   */
  async processQueue() {
    if (this.isProcessingQueue || this.activeRequests >= this.maxConcurrentRequests) {
      return;
    }
    this.isProcessingQueue = true;
    while (this.requestQueue.length > 0 && this.activeRequests < this.maxConcurrentRequests) {
      const { request, resolve, reject } = this.requestQueue.shift();
      this.activeRequests++;
      request().then(resolve).catch(reject).finally(() => {
        this.activeRequests--;
        this.processQueue();
      });
    }
    this.isProcessingQueue = false;
  }
  /**
   * Generate cache key from URL and options
   */
  generateCacheKey(url, options) {
    const method = options.method || "GET";
    const body = options.body ? JSON.stringify(options.body) : "";
    return `${method}:${url}:${body}`;
  }
  /**
   * Clear expired cache entries
   */
  cleanupCache() {
    const now = Date.now();
    for (const [key, entry] of this.requestCache.entries()) {
      if (now > entry.expires) {
        this.requestCache.delete(key);
      }
    }
  }
  /**
   * Enhanced fetch with intelligent caching and retries
   */
  async enhancedFetch(url, options = {}, config = {}) {
    const {
      cache = true,
      cacheTTL = this.cacheDefaultTTL,
      retries = 2,
      retryDelay = 1e3
    } = config;
    if (cache && options.method === "GET") {
      try {
        return await this.cachedRequest(url, options, cacheTTL);
      } catch (error) {
      }
    }
    let lastError;
    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        const response = await this.queueRequest(() => fetch(url, options));
        if (response.ok) {
          return response;
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      } catch (error) {
        lastError = error;
        if (attempt < retries) {
          await new Promise((resolve) => setTimeout(resolve, retryDelay * Math.pow(2, attempt)));
        }
      }
    }
    throw lastError;
  }
  /**
   * Batch multiple operations for efficiency
   */
  async batchExecute(operations, maxConcurrent = 3) {
    const results = [];
    const errors = [];
    for (let i = 0; i < operations.length; i += maxConcurrent) {
      const batch = operations.slice(i, i + maxConcurrent);
      const batchPromises = batch.map(async (op, index) => {
        try {
          return await op();
        } catch (error) {
          errors.push(error);
          return null;
        }
      });
      const batchResults = await Promise.all(batchPromises);
      const validResults = batchResults.filter((result) => result !== null);
      results.push(...validResults);
    }
    if (errors.length > 0) {
      console.warn(`Batch execution completed with ${errors.length} errors:`, errors);
    }
    return results;
  }
  // 5 seconds
  smartNotice(message, type = "info", priority = 1) {
    const notificationKey = `${type}:${message}`;
    const lastShown = this.notificationHistory.get(notificationKey) || 0;
    const now = Date.now();
    if (now - lastShown < this.NOTIFICATION_COOLDOWN && priority <= 1) {
      return;
    }
    this.notificationHistory.set(notificationKey, now);
    const notice = new import_obsidian7.Notice("", this.settings.notificationDuration);
    const noticeEl = notice.noticeEl;
    noticeEl.empty();
    const content = noticeEl.createDiv();
    const iconMap = {
      info: "\u2139\uFE0F",
      success: "\u2705",
      warning: "\u26A0\uFE0F",
      error: "\u274C"
    };
    const colorMap = {
      info: "var(--text-accent)",
      success: "var(--color-green)",
      warning: "var(--color-orange)",
      error: "var(--color-red)"
    };
    content.innerHTML = `
      <div style="display: flex; align-items: center; gap: 8px;">
        <span style="font-size: 16px;">${iconMap[type]}</span>
        <span style="color: ${colorMap[type]}; font-weight: 500;">Thoth:</span>
        <span>${message}</span>
      </div>
    `;
    if (this.notificationHistory.size > 100) {
      const cutoff = now - this.NOTIFICATION_COOLDOWN * 2;
      for (const [key, timestamp] of this.notificationHistory.entries()) {
        if (timestamp < cutoff) {
          this.notificationHistory.delete(key);
        }
      }
    }
  }
  /**
   * Get notification icon based on type
   */
  getNotificationIcon(type) {
    const iconMap = {
      info: "\u{1F535}",
      success: "\u2705",
      warning: "\u26A0\uFE0F",
      error: "\u274C"
    };
    return iconMap[type];
  }
  /**
   * Create a progress notification that can be updated
   */
  createProgressNotification(id, initialMessage, options = {}) {
    const { type = "info", canCancel = false, onCancel, duration = 0 } = options;
    if (this.activeProgressNotifications.has(id)) {
      this.activeProgressNotifications.get(id).close();
    }
    this.loadEnhancedNotificationStyles();
    const notice = new import_obsidian7.Notice("", duration);
    const noticeEl = notice.noticeEl;
    noticeEl.addClass(`thoth-notice-${type}`);
    noticeEl.addClass("thoth-progress-notification");
    noticeEl.innerHTML = `
      <div class="thoth-notice-content">
        <span class="thoth-notice-icon">${this.getNotificationIcon(type)}</span>
        <span class="thoth-progress-message">${initialMessage}</span>
      </div>
      <div class="thoth-progress-container">
        <div class="thoth-progress-bar" style="width: 0%"></div>
      </div>
      ${canCancel ? `
        <div class="thoth-notice-actions">
          <button class="thoth-notice-btn thoth-cancel-btn">\u{1F6AB} Cancel</button>
        </div>
      ` : ""}
    `;
    if (canCancel && onCancel) {
      const cancelBtn = noticeEl.querySelector(".thoth-cancel-btn");
      if (cancelBtn) {
        cancelBtn.onclick = () => {
          onCancel();
          this.closeProgressNotification(id);
        };
      }
    }
    const progressNotification = {
      notice,
      updateProgress: (progress, message) => {
        const progressBar = noticeEl.querySelector(".thoth-progress-bar");
        const messageEl = noticeEl.querySelector(".thoth-progress-message");
        if (progressBar) {
          progressBar.style.width = `${Math.min(100, Math.max(0, progress))}%`;
        }
        if (message && messageEl) {
          messageEl.textContent = message;
        }
      },
      updateMessage: (message) => {
        const messageEl = noticeEl.querySelector(".thoth-progress-message");
        if (messageEl) {
          messageEl.textContent = message;
        }
      },
      close: () => {
        notice.hide();
        this.activeProgressNotifications.delete(id);
      },
      setType: (newType) => {
        noticeEl.removeClass(`thoth-notice-${type}`);
        noticeEl.addClass(`thoth-notice-${newType}`);
        const iconEl = noticeEl.querySelector(".thoth-notice-icon");
        if (iconEl) {
          iconEl.textContent = this.getNotificationIcon(newType);
        }
      }
    };
    this.activeProgressNotifications.set(id, progressNotification);
    return progressNotification;
  }
  /**
   * Update an existing progress notification
   */
  updateProgressNotification(id, progress, message) {
    const notification = this.activeProgressNotifications.get(id);
    if (notification) {
      notification.updateProgress(progress, message);
      return true;
    }
    return false;
  }
  /**
   * Close a progress notification
   */
  closeProgressNotification(id) {
    const notification = this.activeProgressNotifications.get(id);
    if (notification) {
      notification.close();
    }
  }
  /**
   * Create a notification with action buttons
   */
  createActionNotification(message, actions, type = "info", duration = 0) {
    this.loadEnhancedNotificationStyles();
    const notice = new import_obsidian7.Notice("", duration);
    const noticeEl = notice.noticeEl;
    noticeEl.addClass(`thoth-notice-${type}`);
    noticeEl.innerHTML = `
      <div class="thoth-notice-content">
        <span class="thoth-notice-icon">${this.getNotificationIcon(type)}</span>
        ${message}
      </div>
      <div class="thoth-notice-actions">
        ${actions.map((action) => `
          <button class="thoth-notice-btn ${action.style === "primary" ? "primary" : ""}">${action.label}</button>
        `).join("")}
      </div>
    `;
    const actionButtons = noticeEl.querySelectorAll(".thoth-notice-btn");
    actionButtons.forEach((btn, index) => {
      btn.addEventListener("click", () => {
        actions[index].action();
        notice.hide();
      });
    });
  }
  /**
   * Load enhanced notification styles
   */
  loadEnhancedNotificationStyles() {
    if (document.getElementById("thoth-notification-styles")) {
      return;
    }
    const style = document.createElement("style");
    style.id = "thoth-notification-styles";
    style.textContent = `
      .thoth-notice-success {
        background: linear-gradient(135deg, var(--color-green), #4CAF50);
        color: white;
        border-left: 4px solid #2E7D32;
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
      }
      .thoth-notice-warning {
        background: linear-gradient(135deg, var(--color-orange), #FF9800);
        color: white;
        border-left: 4px solid #F57F17;
        box-shadow: 0 4px 12px rgba(255, 152, 0, 0.3);
      }
      .thoth-notice-error {
        background: linear-gradient(135deg, var(--color-red), #F44336);
        color: white;
        border-left: 4px solid #C62828;
        box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
      }
      .thoth-notice-info {
        background: linear-gradient(135deg, var(--interactive-accent), #2196F3);
        color: var(--text-on-accent);
        border-left: 4px solid #1565C0;
        box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
      }
      .thoth-notice-content {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 500;
      }
      .thoth-notice-icon {
        font-size: 1.2em;
        filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));
      }
      .thoth-progress-container {
        margin-top: 8px;
        background: rgba(255,255,255,0.2);
        border-radius: 10px;
        height: 6px;
        overflow: hidden;
      }
      .thoth-progress-bar {
        height: 100%;
        background: rgba(255,255,255,0.8);
        border-radius: 10px;
        transition: width 0.3s ease;
        box-shadow: 0 0 10px rgba(255,255,255,0.3);
      }
      .thoth-notice-actions {
        margin-top: 8px;
        display: flex;
        gap: 8px;
      }
      .thoth-notice-btn {
        padding: 4px 8px;
        background: rgba(255,255,255,0.2);
        border: 1px solid rgba(255,255,255,0.3);
        border-radius: 4px;
        color: inherit;
        cursor: pointer;
        font-size: 0.8em;
        transition: all 0.2s ease;
      }
      .thoth-notice-btn:hover {
        background: rgba(255,255,255,0.3);
        transform: translateY(-1px);
      }
      .thoth-notice-btn.primary {
        background: rgba(255,255,255,0.9);
        color: var(--text-normal);
        font-weight: 600;
      }
      .thoth-progress-notification {
        min-width: 300px;
        animation: slideInRight 0.3s ease;
      }
      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
    `;
    document.head.appendChild(style);
  }
  async debouncedSaveSettings(delay = 1e3) {
    if (this.saveSettingsTimeout) {
      clearTimeout(this.saveSettingsTimeout);
    }
    return new Promise((resolve) => {
      this.saveSettingsTimeout = setTimeout(async () => {
        await this.saveSettings();
        resolve();
      }, delay);
    });
  }
  getPerformanceReport() {
    const uptime = Date.now() - this.performanceMetrics.startTime;
    const cacheSize = this.requestCache.size;
    const queueLength = this.requestQueue.length;
    return {
      uptime: Math.round(uptime / 1e3),
      // seconds
      cacheSize,
      queueLength,
      activeRequests: this.activeRequests,
      ...this.performanceMetrics
    };
  }
  /**
   * Cleanup resources on plugin unload
   */
  onunload() {
    this.closeFloatingPanel();
    this.requestCache.clear();
    this.requestQueue.length = 0;
    if (this.saveSettingsTimeout) {
      clearTimeout(this.saveSettingsTimeout);
    }
    this.stopAgent();
  }
};
var ThothSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Thoth Research Assistant" });
    containerEl.createEl("p", {
      text: "Most settings are now in the Thoth Chat modal. Open the chat to access full settings."
    });
    new import_obsidian7.Setting(containerEl).setName("Remote Mode").setDesc("Connect to a remote Thoth server (required for mobile)").addToggle((toggle) => toggle.setValue(this.plugin.settings.remoteMode).onChange(async (value) => {
      this.plugin.settings.remoteMode = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.remoteMode) {
      new import_obsidian7.Setting(containerEl).setName("Thoth API URL").setDesc("URL of the Thoth API server (research, discovery, PDF processing)").addText((text) => text.setPlaceholder("http://localhost:8000").setValue(this.plugin.settings.remoteEndpointUrl).onChange(async (value) => {
        this.plugin.settings.remoteEndpointUrl = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian7.Setting(containerEl).setName("Letta API URL").setDesc("URL of the Letta API server (agent chat functionality)").addText((text) => text.setPlaceholder("http://localhost:8284").setValue(this.plugin.settings.lettaEndpointUrl).onChange(async (value) => {
        this.plugin.settings.lettaEndpointUrl = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian7.Setting(containerEl).setName("Auto-start Agent").setDesc("Automatically start local agent on Obsidian startup (desktop only)").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoStartAgent).onChange(async (value) => {
      this.plugin.settings.autoStartAgent = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Show Status Bar").setDesc("Show Thoth status in the status bar").addToggle((toggle) => toggle.setValue(this.plugin.settings.showStatusBar).onChange(async (value) => {
      this.plugin.settings.showStatusBar = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Show Ribbon Icon").setDesc("Show Thoth icon in the left ribbon").addToggle((toggle) => toggle.setValue(this.plugin.settings.showRibbonIcon).onChange(async (value) => {
      this.plugin.settings.showRibbonIcon = value;
      await this.plugin.saveSettings();
    }));
    const linkSetting = new import_obsidian7.Setting(containerEl).setName("Full Settings").setDesc("Open Thoth Chat to access all settings including backend configuration");
    linkSetting.controlEl.createEl("button", {
      text: "Open Thoth Chat",
      cls: "mod-cta"
    }).onclick = () => {
      new MultiChatModal(this.app, this.plugin).open();
    };
  }
};
